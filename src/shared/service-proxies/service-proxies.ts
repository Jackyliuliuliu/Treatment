/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.20.1.0 (NJsonSchema v9.11.0.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { AppAuthorization} from '@shared/Permission/AppAuthorization';
import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, from as _observableFrom, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export class ServiceBase {
    protected transformOptions(options: any) {
        // TODO: Change options if required
        const token = AppAuthorization.getToken();
        if (token) {
            options.headers = options.headers.set('Authorization', 'Bearer ' + token);
        }
        return Promise.resolve(options);
    }
}

@Injectable()
export class BeamServiceProxy extends ServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createBeam(input: AddBeamDto | null | undefined): Observable<BeamOutput> {
        let url_ = this.baseUrl + "/api/services/app/Beam/CreateBeam";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateBeam(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateBeam(<any>response_);
                } catch (e) {
                    return <Observable<BeamOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<BeamOutput>><any>_observableThrow(response_);
        }));
    }

    protected processCreateBeam(response: HttpResponseBase): Observable<BeamOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BeamOutput.fromJS(resultData200) : new BeamOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BeamOutput>(<any>null);
    }

    /**
     * @param beamId (optional) 
     * @return Success
     */
    deleteBeam(beamId: number | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Beam/DeleteBeam?";
        if (beamId !== undefined)
            url_ += "beamId=" + encodeURIComponent("" + beamId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteBeam(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteBeam(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteBeam(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param beamId (optional) 
     * @return Success
     */
    getBeamNameByIndex(beamId: number | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Beam/GetBeamNameByIndex?";
        if (beamId !== undefined)
            url_ += "beamId=" + encodeURIComponent("" + beamId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetBeamNameByIndex(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBeamNameByIndex(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetBeamNameByIndex(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param beamId (optional) 
     * @return Success
     */
    getBeamInfoByIndex(beamId: number | null | undefined): Observable<BeamDto> {
        let url_ = this.baseUrl + "/api/services/app/Beam/GetBeamInfoByIndex?";
        if (beamId !== undefined)
            url_ += "beamId=" + encodeURIComponent("" + beamId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetBeamInfoByIndex(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBeamInfoByIndex(<any>response_);
                } catch (e) {
                    return <Observable<BeamDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BeamDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBeamInfoByIndex(response: HttpResponseBase): Observable<BeamDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BeamDto.fromJS(resultData200) : new BeamDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BeamDto>(<any>null);
    }

    /**
     * @param beamId (optional) 
     * @return Success
     */
    getBeamImageByIndex(beamId: number | null | undefined): Observable<BeamDto> {
        let url_ = this.baseUrl + "/api/services/app/Beam/GetBeamImageByIndex?";
        if (beamId !== undefined)
            url_ += "beamId=" + encodeURIComponent("" + beamId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetBeamImageByIndex(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBeamImageByIndex(<any>response_);
                } catch (e) {
                    return <Observable<BeamDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BeamDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBeamImageByIndex(response: HttpResponseBase): Observable<BeamDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BeamDto.fromJS(resultData200) : new BeamDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BeamDto>(<any>null);
    }

    /**
     * @param beam (optional) 
     * @return Success
     */
    updateBeam(beam: BeamDto | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Beam/UpdateBeam";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(beam);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateBeam(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBeam(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateBeam(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param controlPoint (optional) 
     * @return Success
     */
    updateControlPoint(controlPoint: ControlPointDto | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Beam/UpdateControlPoint";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(controlPoint);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateControlPoint(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateControlPoint(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateControlPoint(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param segments (optional) 
     * @return Success
     */
    updateControlPointList(segments: ControlPointDto[] | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Beam/UpdateControlPointList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(segments);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateControlPointList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateControlPointList(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateControlPointList(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    copyBeam(input: CopyBeamDto | null | undefined): Observable<BeamOutput> {
        let url_ = this.baseUrl + "/api/services/app/Beam/CopyBeam";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCopyBeam(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCopyBeam(<any>response_);
                } catch (e) {
                    return <Observable<BeamOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<BeamOutput>><any>_observableThrow(response_);
        }));
    }

    protected processCopyBeam(response: HttpResponseBase): Observable<BeamOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BeamOutput.fromJS(resultData200) : new BeamOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BeamOutput>(<any>null);
    }

    /**
     * @param beamId (optional) 
     * @return Success
     */
    checkBeam(beamId: number | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Beam/CheckBeam?";
        if (beamId !== undefined)
            url_ += "beamId=" + encodeURIComponent("" + beamId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCheckBeam(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckBeam(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processCheckBeam(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param beamId (optional) 
     * @return Success
     */
    unCheckBeam(beamId: number | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Beam/UnCheckBeam?";
        if (beamId !== undefined)
            url_ += "beamId=" + encodeURIComponent("" + beamId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUnCheckBeam(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnCheckBeam(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processUnCheckBeam(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param beam (optional) 
     * @return Success
     */
    updatePortImageBeam(beam: BeamDto | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Beam/UpdatePortImageBeam";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(beam);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdatePortImageBeam(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePortImageBeam(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePortImageBeam(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

@Injectable()
export class BeamGroupServiceProxy extends ServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    addBeamGroup(input: AddBeamGroupDto | null | undefined): Observable<BeamGroupDto> {
        let url_ = this.baseUrl + "/api/services/app/BeamGroup/AddBeamGroup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processAddBeamGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddBeamGroup(<any>response_);
                } catch (e) {
                    return <Observable<BeamGroupDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BeamGroupDto>><any>_observableThrow(response_);
        }));
    }

    protected processAddBeamGroup(response: HttpResponseBase): Observable<BeamGroupDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BeamGroupDto.fromJS(resultData200) : new BeamGroupDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BeamGroupDto>(<any>null);
    }

    /**
     * @param beamGroupId (optional) 
     * @return Success
     */
    getBeamGroupNameById(beamGroupId: number | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/BeamGroup/GetBeamGroupNameById?";
        if (beamGroupId !== undefined)
            url_ += "beamGroupId=" + encodeURIComponent("" + beamGroupId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetBeamGroupNameById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBeamGroupNameById(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetBeamGroupNameById(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param patientId (optional) 
     * @return Success
     */
    getAllBeamGroupTreeByPatientId(patientId: number | null | undefined): Observable<BeamGroupOutput[]> {
        let url_ = this.baseUrl + "/api/services/app/BeamGroup/GetAllBeamGroupTreeByPatientId?";
        if (patientId !== undefined)
            url_ += "patientId=" + encodeURIComponent("" + patientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAllBeamGroupTreeByPatientId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBeamGroupTreeByPatientId(<any>response_);
                } catch (e) {
                    return <Observable<BeamGroupOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BeamGroupOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllBeamGroupTreeByPatientId(response: HttpResponseBase): Observable<BeamGroupOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BeamGroupOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BeamGroupOutput[]>(<any>null);
    }

    /**
     * @param beamGroup (optional) 
     * @return Success
     */
    updateBeamGroup(beamGroup: BeamGroupDto | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/BeamGroup/UpdateBeamGroup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(beamGroup);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateBeamGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBeamGroup(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateBeamGroup(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param beamGroup (optional) 
     * @return Success
     */
    updateOffset(beamGroup: BeamGroupDto | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/BeamGroup/UpdateOffset";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(beamGroup);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateOffset(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOffset(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOffset(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param beamGroup (optional) 
     * @return Success
     */
    updateBeamGroupImages(beamGroup: BeamGroupDto | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/BeamGroup/UpdateBeamGroupImages";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(beamGroup);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateBeamGroupImages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBeamGroupImages(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateBeamGroupImages(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param beamGroup (optional) 
     * @return Success
     */
    updateBeamGroupDeviceImages(beamGroup: BeamGroupDto | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/BeamGroup/UpdateBeamGroupDeviceImages";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(beamGroup);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateBeamGroupDeviceImages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBeamGroupDeviceImages(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateBeamGroupDeviceImages(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param beamGroupId (optional) 
     * @return Success
     */
    getBeamGroupImages(beamGroupId: number | null | undefined): Observable<BeamGroupImageDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BeamGroup/GetBeamGroupImages?";
        if (beamGroupId !== undefined)
            url_ += "beamGroupId=" + encodeURIComponent("" + beamGroupId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetBeamGroupImages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBeamGroupImages(<any>response_);
                } catch (e) {
                    return <Observable<BeamGroupImageDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BeamGroupImageDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetBeamGroupImages(response: HttpResponseBase): Observable<BeamGroupImageDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BeamGroupImageDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BeamGroupImageDto[]>(<any>null);
    }

    /**
     * @param beamGroupId (optional) 
     * @return Success
     */
    getFixationDeviceImages(beamGroupId: number | null | undefined): Observable<FixationDeviceImageDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BeamGroup/GetFixationDeviceImages?";
        if (beamGroupId !== undefined)
            url_ += "beamGroupId=" + encodeURIComponent("" + beamGroupId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetFixationDeviceImages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFixationDeviceImages(<any>response_);
                } catch (e) {
                    return <Observable<FixationDeviceImageDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FixationDeviceImageDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetFixationDeviceImages(response: HttpResponseBase): Observable<FixationDeviceImageDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(FixationDeviceImageDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FixationDeviceImageDto[]>(<any>null);
    }

    /**
     * @param beamGroupId (optional) 
     * @return Success
     */
    deleteBeamGroup(beamGroupId: number | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/BeamGroup/DeleteBeamGroup?";
        if (beamGroupId !== undefined)
            url_ += "beamGroupId=" + encodeURIComponent("" + beamGroupId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteBeamGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteBeamGroup(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteBeamGroup(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param beamGroupId (optional) 
     * @return Success
     */
    getBeamGroupInfoByIndex(beamGroupId: number | null | undefined): Observable<BeamGroupDto> {
        let url_ = this.baseUrl + "/api/services/app/BeamGroup/GetBeamGroupInfoByIndex?";
        if (beamGroupId !== undefined)
            url_ += "beamGroupId=" + encodeURIComponent("" + beamGroupId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetBeamGroupInfoByIndex(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBeamGroupInfoByIndex(<any>response_);
                } catch (e) {
                    return <Observable<BeamGroupDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BeamGroupDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBeamGroupInfoByIndex(response: HttpResponseBase): Observable<BeamGroupDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BeamGroupDto.fromJS(resultData200) : new BeamGroupDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BeamGroupDto>(<any>null);
    }

    /**
     * @param planId (optional) 
     * @return Success
     */
    getSetUpInfo(planId: number | null | undefined): Observable<SetupDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BeamGroup/GetSetUpInfo?";
        if (planId !== undefined)
            url_ += "planId=" + encodeURIComponent("" + planId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetSetUpInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSetUpInfo(<any>response_);
                } catch (e) {
                    return <Observable<SetupDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SetupDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSetUpInfo(response: HttpResponseBase): Observable<SetupDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(SetupDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SetupDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    checkBeamGoupDuplicate(input: AddBeamGroupDto | null | undefined): Observable<CheckBeamGroupResult> {
        let url_ = this.baseUrl + "/api/services/app/BeamGroup/CheckBeamGoupDuplicate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCheckBeamGoupDuplicate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckBeamGoupDuplicate(<any>response_);
                } catch (e) {
                    return <Observable<CheckBeamGroupResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CheckBeamGroupResult>><any>_observableThrow(response_);
        }));
    }

    protected processCheckBeamGoupDuplicate(response: HttpResponseBase): Observable<CheckBeamGroupResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CheckBeamGroupResult.fromJS(resultData200) : new CheckBeamGroupResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CheckBeamGroupResult>(<any>null);
    }

    /**
     * @param beamGroupId (optional) 
     * @return Success
     */
    copyBeamGroup(beamGroupId: number | null | undefined): Observable<BeamGroupDto> {
        let url_ = this.baseUrl + "/api/services/app/BeamGroup/CopyBeamGroup?";
        if (beamGroupId !== undefined)
            url_ += "beamGroupId=" + encodeURIComponent("" + beamGroupId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCopyBeamGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCopyBeamGroup(<any>response_);
                } catch (e) {
                    return <Observable<BeamGroupDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BeamGroupDto>><any>_observableThrow(response_);
        }));
    }

    protected processCopyBeamGroup(response: HttpResponseBase): Observable<BeamGroupDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BeamGroupDto.fromJS(resultData200) : new BeamGroupDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BeamGroupDto>(<any>null);
    }

    /**
     * @param patientId (optional) 
     * @return Success
     */
    getAllBeamGroupsByPatientId(patientId: number | null | undefined): Observable<BeamGroupDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BeamGroup/GetAllBeamGroupsByPatientId?";
        if (patientId !== undefined)
            url_ += "patientId=" + encodeURIComponent("" + patientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAllBeamGroupsByPatientId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBeamGroupsByPatientId(<any>response_);
                } catch (e) {
                    return <Observable<BeamGroupDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BeamGroupDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllBeamGroupsByPatientId(response: HttpResponseBase): Observable<BeamGroupDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BeamGroupDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BeamGroupDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllMachines(): Observable<MachineOutput[]> {
        let url_ = this.baseUrl + "/api/services/app/BeamGroup/GetAllMachines";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAllMachines(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMachines(<any>response_);
                } catch (e) {
                    return <Observable<MachineOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MachineOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllMachines(response: HttpResponseBase): Observable<MachineOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(MachineOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MachineOutput[]>(<any>null);
    }

    /**
     * @param patientId (optional) 
     * @return Success
     */
    getAllPrescriptionByPatientId(patientId: number | null | undefined): Observable<PresciprionOutput[]> {
        let url_ = this.baseUrl + "/api/services/app/BeamGroup/GetAllPrescriptionByPatientId?";
        if (patientId !== undefined)
            url_ += "patientId=" + encodeURIComponent("" + patientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAllPrescriptionByPatientId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPrescriptionByPatientId(<any>response_);
                } catch (e) {
                    return <Observable<PresciprionOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PresciprionOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPrescriptionByPatientId(response: HttpResponseBase): Observable<PresciprionOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PresciprionOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PresciprionOutput[]>(<any>null);
    }

    /**
     * @param beamGroupId (optional) 
     * @return Success
     */
    printBeamGroupReport(beamGroupId: number | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/BeamGroup/PrintBeamGroupReport?";
        if (beamGroupId !== undefined)
            url_ += "beamGroupId=" + encodeURIComponent("" + beamGroupId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processPrintBeamGroupReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrintBeamGroupReport(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processPrintBeamGroupReport(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param beamGroupId (optional) 
     * @return Success
     */
    getFractionNumberByBeamgroup(beamGroupId: number | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/BeamGroup/GetFractionNumberByBeamgroup?";
        if (beamGroupId !== undefined)
            url_ += "beamGroupId=" + encodeURIComponent("" + beamGroupId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetFractionNumberByBeamgroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFractionNumberByBeamgroup(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetFractionNumberByBeamgroup(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param patientId (optional) 
     * @return Success
     */
    getBeamGroupNum(patientId: number | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/BeamGroup/GetBeamGroupNum?";
        if (patientId !== undefined)
            url_ += "patientId=" + encodeURIComponent("" + patientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetBeamGroupNum(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBeamGroupNum(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetBeamGroupNum(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param beamgroupId (optional) 
     * @return Success
     */
    activeBeamGroup(beamgroupId: number | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/BeamGroup/ActiveBeamGroup?";
        if (beamgroupId !== undefined)
            url_ += "beamgroupId=" + encodeURIComponent("" + beamgroupId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processActiveBeamGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActiveBeamGroup(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processActiveBeamGroup(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param beamgroupId (optional) 
     * @return Success
     */
    inActiveBeamGroup(beamgroupId: number | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/BeamGroup/InActiveBeamGroup?";
        if (beamgroupId !== undefined)
            url_ += "beamgroupId=" + encodeURIComponent("" + beamgroupId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processInActiveBeamGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInActiveBeamGroup(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processInActiveBeamGroup(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param beamgroupId (optional) 
     * @param approver (optional) 
     * @return Success
     */
    approveBeamGroup(beamgroupId: number | null | undefined, approver: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/BeamGroup/ApproveBeamGroup?";
        if (beamgroupId !== undefined)
            url_ += "beamgroupId=" + encodeURIComponent("" + beamgroupId) + "&"; 
        if (approver !== undefined)
            url_ += "approver=" + encodeURIComponent("" + approver) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processApproveBeamGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveBeamGroup(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processApproveBeamGroup(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param beamgroupId (optional) 
     * @return Success
     */
    unApproveBeamGroup(beamgroupId: number | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/BeamGroup/UnApproveBeamGroup?";
        if (beamgroupId !== undefined)
            url_ += "beamgroupId=" + encodeURIComponent("" + beamgroupId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUnApproveBeamGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnApproveBeamGroup(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processUnApproveBeamGroup(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param beamGroupId (optional) 
     * @return Success
     */
    getBeamGroupStatus(beamGroupId: number | null | undefined): Observable<BeamGroupStatusDto> {
        let url_ = this.baseUrl + "/api/services/app/BeamGroup/GetBeamGroupStatus?";
        if (beamGroupId !== undefined)
            url_ += "beamGroupId=" + encodeURIComponent("" + beamGroupId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetBeamGroupStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBeamGroupStatus(<any>response_);
                } catch (e) {
                    return <Observable<BeamGroupStatusDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BeamGroupStatusDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBeamGroupStatus(response: HttpResponseBase): Observable<BeamGroupStatusDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BeamGroupStatusDto.fromJS(resultData200) : new BeamGroupStatusDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BeamGroupStatusDto>(<any>null);
    }

    /**
     * @param beamGroupId (optional) 
     * @return Success
     */
    checkBeams(beamGroupId: number | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/BeamGroup/CheckBeams?";
        if (beamGroupId !== undefined)
            url_ += "beamGroupId=" + encodeURIComponent("" + beamGroupId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCheckBeams(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckBeams(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processCheckBeams(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

@Injectable()
export class BeamsTreatmentRecordServiceProxy extends ServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param beamGroupId (optional) 
     * @return Success
     */
    isBeamGroupHasRecord(beamGroupId: number | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/BeamsTreatmentRecord/IsBeamGroupHasRecord?";
        if (beamGroupId !== undefined)
            url_ += "beamGroupId=" + encodeURIComponent("" + beamGroupId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processIsBeamGroupHasRecord(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsBeamGroupHasRecord(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processIsBeamGroupHasRecord(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRecordCalendarData(id: number | null | undefined): Observable<TreatmentSummaryDto> {
        let url_ = this.baseUrl + "/api/services/app/BeamsTreatmentRecord/GetRecordCalendarData?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetRecordCalendarData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecordCalendarData(<any>response_);
                } catch (e) {
                    return <Observable<TreatmentSummaryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TreatmentSummaryDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecordCalendarData(response: HttpResponseBase): Observable<TreatmentSummaryDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TreatmentSummaryDto.fromJS(resultData200) : new TreatmentSummaryDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TreatmentSummaryDto>(<any>null);
    }

    /**
     * @param beamGroupId (optional) 
     * @return Success
     */
    printBeamGroupRecord(beamGroupId: number | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/BeamsTreatmentRecord/PrintBeamGroupRecord?";
        if (beamGroupId !== undefined)
            url_ += "beamGroupId=" + encodeURIComponent("" + beamGroupId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processPrintBeamGroupRecord(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrintBeamGroupRecord(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processPrintBeamGroupRecord(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    getRecordDetailsByBeamIds(ids: number[] | null | undefined): Observable<RecordDetailsOutput> {
        let url_ = this.baseUrl + "/api/services/app/BeamsTreatmentRecord/GetRecordDetailsByBeamIds?";
        if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetRecordDetailsByBeamIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecordDetailsByBeamIds(<any>response_);
                } catch (e) {
                    return <Observable<RecordDetailsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<RecordDetailsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecordDetailsByBeamIds(response: HttpResponseBase): Observable<RecordDetailsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RecordDetailsOutput.fromJS(resultData200) : new RecordDetailsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RecordDetailsOutput>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @param sortKey (optional) 
     * @param sortValue (optional) 
     * @return Success
     */
    getRecordDetailsByBeamIdsWithSort(ids: number[] | null | undefined, sortKey: string | null | undefined, sortValue: string | null | undefined): Observable<RecordDetailsOutput> {
        let url_ = this.baseUrl + "/api/services/app/BeamsTreatmentRecord/GetRecordDetailsByBeamIdsWithSort?";
        if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        if (sortKey !== undefined)
            url_ += "sortKey=" + encodeURIComponent("" + sortKey) + "&"; 
        if (sortValue !== undefined)
            url_ += "sortValue=" + encodeURIComponent("" + sortValue) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetRecordDetailsByBeamIdsWithSort(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecordDetailsByBeamIdsWithSort(<any>response_);
                } catch (e) {
                    return <Observable<RecordDetailsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<RecordDetailsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecordDetailsByBeamIdsWithSort(response: HttpResponseBase): Observable<RecordDetailsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RecordDetailsOutput.fromJS(resultData200) : new RecordDetailsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RecordDetailsOutput>(<any>null);
    }
}

@Injectable()
export class BeamsTreatmentScheduleServiceProxy extends ServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDeliveryGroupsByPatient(id: number | null | undefined): Observable<TreatmentScheduleDeliveryGroupDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BeamsTreatmentSchedule/GetDeliveryGroupsByPatient?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetDeliveryGroupsByPatient(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeliveryGroupsByPatient(<any>response_);
                } catch (e) {
                    return <Observable<TreatmentScheduleDeliveryGroupDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TreatmentScheduleDeliveryGroupDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeliveryGroupsByPatient(response: HttpResponseBase): Observable<TreatmentScheduleDeliveryGroupDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TreatmentScheduleDeliveryGroupDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TreatmentScheduleDeliveryGroupDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllSessions(): Observable<TreatmentScheduleSessionDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BeamsTreatmentSchedule/GetAllSessions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAllSessions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSessions(<any>response_);
                } catch (e) {
                    return <Observable<TreatmentScheduleSessionDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TreatmentScheduleSessionDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSessions(response: HttpResponseBase): Observable<TreatmentScheduleSessionDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TreatmentScheduleSessionDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TreatmentScheduleSessionDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    querySessionsByBeamGroupId(input: QueryBeamGroupSessionDto | null | undefined): Observable<PagedResultDtoOfTreatmentScheduleSessionDto> {
        let url_ = this.baseUrl + "/api/services/app/BeamsTreatmentSchedule/QuerySessionsByBeamGroupId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processQuerySessionsByBeamGroupId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQuerySessionsByBeamGroupId(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTreatmentScheduleSessionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTreatmentScheduleSessionDto>><any>_observableThrow(response_);
        }));
    }

    protected processQuerySessionsByBeamGroupId(response: HttpResponseBase): Observable<PagedResultDtoOfTreatmentScheduleSessionDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTreatmentScheduleSessionDto.fromJS(resultData200) : new PagedResultDtoOfTreatmentScheduleSessionDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTreatmentScheduleSessionDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    delete(input: any[] | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/BeamsTreatmentSchedule/Delete?";
        if (input !== undefined)
            input && input.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "input[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param sessionUids (optional) 
     * @param hours (optional) 
     * @param minutes (optional) 
     * @param isDelay (optional) 
     * @return Success
     */
    batchTimeShiftingSessions(sessionUids: number[] | null | undefined, hours: number | null | undefined, minutes: number | null | undefined, isDelay: boolean | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/BeamsTreatmentSchedule/BatchTimeShiftingSessions?";
        if (hours !== undefined)
            url_ += "hours=" + encodeURIComponent("" + hours) + "&"; 
        if (minutes !== undefined)
            url_ += "minutes=" + encodeURIComponent("" + minutes) + "&"; 
        if (isDelay !== undefined)
            url_ += "isDelay=" + encodeURIComponent("" + isDelay) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sessionUids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processBatchTimeShiftingSessions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchTimeShiftingSessions(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processBatchTimeShiftingSessions(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param sessionUids (optional) 
     * @param newPlanDate (optional) 
     * @param isAll (optional) 
     * @return Success
     */
    batchTimeShiftSession(sessionUids: number[] | null | undefined, newPlanDate: moment.Moment | null | undefined, isAll: boolean | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/BeamsTreatmentSchedule/BatchTimeShiftSession?";
        if (newPlanDate !== undefined)
            url_ += "newPlanDate=" + encodeURIComponent(newPlanDate ? "" + newPlanDate.toJSON() : "") + "&"; 
        if (isAll !== undefined)
            url_ += "isAll=" + encodeURIComponent("" + isAll) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sessionUids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processBatchTimeShiftSession(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchTimeShiftSession(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processBatchTimeShiftSession(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateTreatmentSessionOfDG(input: TreatmentScheduleStrategyDto | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/BeamsTreatmentSchedule/UpdateTreatmentSessionOfDG";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateTreatmentSessionOfDG(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTreatmentSessionOfDG(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTreatmentSessionOfDG(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param beamGroupId (optional) 
     * @return Success
     */
    getScheduleStrategyByDG(beamGroupId: number | null | undefined): Observable<TreatmentScheduleStrategyDto> {
        let url_ = this.baseUrl + "/api/services/app/BeamsTreatmentSchedule/GetScheduleStrategyByDG?";
        if (beamGroupId !== undefined)
            url_ += "beamGroupId=" + encodeURIComponent("" + beamGroupId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetScheduleStrategyByDG(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetScheduleStrategyByDG(<any>response_);
                } catch (e) {
                    return <Observable<TreatmentScheduleStrategyDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TreatmentScheduleStrategyDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetScheduleStrategyByDG(response: HttpResponseBase): Observable<TreatmentScheduleStrategyDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TreatmentScheduleStrategyDto.fromJS(resultData200) : new TreatmentScheduleStrategyDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TreatmentScheduleStrategyDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    generateSession(input: TreatmentScheduleStrategyDto | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/BeamsTreatmentSchedule/GenerateSession";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGenerateSession(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateSession(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processGenerateSession(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param beamGroupId (optional) 
     * @return Success
     */
    getSessionsByBeamGroupId(beamGroupId: number | null | undefined): Observable<TreatmentScheduleSessionDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BeamsTreatmentSchedule/GetSessionsByBeamGroupId?";
        if (beamGroupId !== undefined)
            url_ += "beamGroupId=" + encodeURIComponent("" + beamGroupId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetSessionsByBeamGroupId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSessionsByBeamGroupId(<any>response_);
                } catch (e) {
                    return <Observable<TreatmentScheduleSessionDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TreatmentScheduleSessionDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSessionsByBeamGroupId(response: HttpResponseBase): Observable<TreatmentScheduleSessionDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TreatmentScheduleSessionDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TreatmentScheduleSessionDto[]>(<any>null);
    }

    /**
     * @param sessionUids (optional) 
     * @param planDate (optional) 
     * @param isAll (optional) 
     * @return Success
     */
    batchDateChangeSessions(sessionUids: number[] | null | undefined, planDate: moment.Moment | null | undefined, isAll: boolean | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/BeamsTreatmentSchedule/BatchDateChangeSessions?";
        if (planDate !== undefined)
            url_ += "planDate=" + encodeURIComponent(planDate ? "" + planDate.toJSON() : "") + "&"; 
        if (isAll !== undefined)
            url_ += "isAll=" + encodeURIComponent("" + isAll) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sessionUids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processBatchDateChangeSessions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDateChangeSessions(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDateChangeSessions(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param sessionUids (optional) 
     * @param days (optional) 
     * @param isDelay (optional) 
     * @return Success
     */
    batchDateShiftSessions(sessionUids: number[] | null | undefined, days: number | null | undefined, isDelay: boolean | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/BeamsTreatmentSchedule/BatchDateShiftSessions?";
        if (days !== undefined)
            url_ += "days=" + encodeURIComponent("" + days) + "&"; 
        if (isDelay !== undefined)
            url_ += "isDelay=" + encodeURIComponent("" + isDelay) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sessionUids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processBatchDateShiftSessions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDateShiftSessions(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDateShiftSessions(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param sessionUids (optional) 
     * @param isActive (optional) 
     * @return Success
     */
    bathActiveOrInactiveSessions(sessionUids: number[] | null | undefined, isActive: boolean | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/BeamsTreatmentSchedule/BathActiveOrInactiveSessions?";
        if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sessionUids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processBathActiveOrInactiveSessions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBathActiveOrInactiveSessions(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processBathActiveOrInactiveSessions(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

@Injectable()
export class ConfigurationServiceProxy extends ServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    changeUiTheme(input: ChangeUiThemeInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Configuration/ChangeUiTheme";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processChangeUiTheme(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeUiTheme(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeUiTheme(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class EnumServiceProxy extends ServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param type (optional) 
     * @return Success
     */
    getMap(type: string | null | undefined): Observable<{ [key: string] : number; }> {
        let url_ = this.baseUrl + "/api/services/app/Enum/GetMap?";
        if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetMap(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMap(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : number; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : number; }>><any>_observableThrow(response_);
        }));
    }

    protected processGetMap(response: HttpResponseBase): Observable<{ [key: string] : number; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : number; }>(<any>null);
    }

    /**
     * @return Success
     */
    getAllMaps(): Observable<{ [key: string] : { [key: string] : number; }; }> {
        let url_ = this.baseUrl + "/api/services/app/Enum/GetAllMaps";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAllMaps(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMaps(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : { [key: string] : number; }; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : { [key: string] : number; }; }>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllMaps(response: HttpResponseBase): Observable<{ [key: string] : { [key: string] : number; }; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key] !== undefined ? resultData200[key] : {};
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : { [key: string] : number; }; }>(<any>null);
    }
}

@Injectable()
export class LicenseServiceProxy extends ServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllLicense(): Observable<LicenseOutput[]> {
        let url_ = this.baseUrl + "/api/services/app/License/GetAllLicense";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAllLicense(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllLicense(<any>response_);
                } catch (e) {
                    return <Observable<LicenseOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LicenseOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllLicense(response: HttpResponseBase): Observable<LicenseOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(LicenseOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LicenseOutput[]>(<any>null);
    }
}

@Injectable()
export class MachinetreatmentScheduleServiceServiceProxy extends ServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    queryAllSessions(input: QueryAllSessionInput | null | undefined): Observable<PagedResultDtoOfTreatmentSessionDto> {
        let url_ = this.baseUrl + "/api/services/app/MachinetreatmentScheduleService/QueryAllSessions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processQueryAllSessions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQueryAllSessions(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTreatmentSessionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTreatmentSessionDto>><any>_observableThrow(response_);
        }));
    }

    protected processQueryAllSessions(response: HttpResponseBase): Observable<PagedResultDtoOfTreatmentSessionDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTreatmentSessionDto.fromJS(resultData200) : new PagedResultDtoOfTreatmentSessionDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTreatmentSessionDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAllMachineNames(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/MachinetreatmentScheduleService/GetAllMachineNames";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAllMachineNames(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMachineNames(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllMachineNames(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteSessionsById(ids: number[] | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/MachinetreatmentScheduleService/DeleteSessionsById?";
        if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteSessionsById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSessionsById(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteSessionsById(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

@Injectable()
export class PatientServiceProxy extends ServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param patientFolderIds (optional) 
     * @param pageSize (optional) 
     * @param pageIndex (optional) 
     * @param searchCriteria (optional) 
     * @param sorter (optional) 
     * @return Success
     */
    getAll(patientFolderIds: number[] | null | undefined, pageSize: number | null | undefined, pageIndex: number | null | undefined, searchCriteria: string | null | undefined, sorter: Sorter | null | undefined): Observable<ListResultDtoOfPatientDto> {
        let url_ = this.baseUrl + "/api/services/app/Patient/GetAll?";
        if (patientFolderIds !== undefined)
            patientFolderIds && patientFolderIds.forEach(item => { url_ += "PatientFolderIds=" + encodeURIComponent("" + item) + "&"; });
        if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        if (searchCriteria !== undefined)
            url_ += "SearchCriteria=" + encodeURIComponent("" + searchCriteria) + "&"; 
        if (sorter !== undefined)
            url_ += "Sorter=" + encodeURIComponent("" + sorter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfPatientDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfPatientDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ListResultDtoOfPatientDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfPatientDto.fromJS(resultData200) : new ListResultDtoOfPatientDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfPatientDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAllPatients(): Observable<PatientDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Patient/GetAllPatients";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAllPatients(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPatients(<any>response_);
                } catch (e) {
                    return <Observable<PatientDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PatientDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPatients(response: HttpResponseBase): Observable<PatientDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PatientDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PatientDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<PatientDto> {
        let url_ = this.baseUrl + "/api/services/app/Patient/Get?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<PatientDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PatientDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PatientDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PatientDto.fromJS(resultData200) : new PatientDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PatientDto>(<any>null);
    }
}

@Injectable()
export class PermissionServiceProxy extends ServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param permissionName (optional) 
     * @return Success
     */
    isGranted(permissionName: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Permission/IsGranted?";
        if (permissionName !== undefined)
            url_ += "permissionName=" + encodeURIComponent("" + permissionName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processIsGranted(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsGranted(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processIsGranted(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

@Injectable()
export class ReportPrintServiceProxy extends ServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    testPrint(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ReportPrint/TestPrint";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processTestPrint(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestPrint(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processTestPrint(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TableDisplayConfigServiceProxy extends ServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getDefaultRecordDisplay(): Observable<TableDisplayConfigDto[]> {
        let url_ = this.baseUrl + "/api/services/app/TableDisplayConfig/GetDefaultRecordDisplay";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetDefaultRecordDisplay(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDefaultRecordDisplay(<any>response_);
                } catch (e) {
                    return <Observable<TableDisplayConfigDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TableDisplayConfigDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDefaultRecordDisplay(response: HttpResponseBase): Observable<TableDisplayConfigDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TableDisplayConfigDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TableDisplayConfigDto[]>(<any>null);
    }

    /**
     * @param recordDisplayConfigs (optional) 
     * @return Success
     */
    saveRecordDisplay(recordDisplayConfigs: TableDisplayConfigDto[] | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/TableDisplayConfig/SaveRecordDisplay";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(recordDisplayConfigs);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSaveRecordDisplay(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveRecordDisplay(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processSaveRecordDisplay(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

@Injectable()
export class ToleranceServiceProxy extends ServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param toleranceId (optional) 
     * @return Success
     */
    copyTolerance(toleranceId: number | null | undefined): Observable<ToleranceDto> {
        let url_ = this.baseUrl + "/api/services/app/Tolerance/CopyTolerance?";
        if (toleranceId !== undefined)
            url_ += "toleranceId=" + encodeURIComponent("" + toleranceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCopyTolerance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCopyTolerance(<any>response_);
                } catch (e) {
                    return <Observable<ToleranceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ToleranceDto>><any>_observableThrow(response_);
        }));
    }

    protected processCopyTolerance(response: HttpResponseBase): Observable<ToleranceDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ToleranceDto.fromJS(resultData200) : new ToleranceDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ToleranceDto>(<any>null);
    }

    /**
     * @param tolerance (optional) 
     * @return Success
     */
    createTolerance(tolerance: ToleranceDto | null | undefined): Observable<ToleranceDto> {
        let url_ = this.baseUrl + "/api/services/app/Tolerance/CreateTolerance";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tolerance);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateTolerance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTolerance(<any>response_);
                } catch (e) {
                    return <Observable<ToleranceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ToleranceDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateTolerance(response: HttpResponseBase): Observable<ToleranceDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ToleranceDto.fromJS(resultData200) : new ToleranceDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ToleranceDto>(<any>null);
    }

    /**
     * @param toleranceId (optional) 
     * @return Success
     */
    deleteTolerance(toleranceId: number | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Tolerance/DeleteTolerance?";
        if (toleranceId !== undefined)
            url_ += "toleranceId=" + encodeURIComponent("" + toleranceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteTolerance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTolerance(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTolerance(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @return Success
     */
    getAllTolerance(): Observable<ToleranceDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Tolerance/GetAllTolerance";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAllTolerance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTolerance(<any>response_);
                } catch (e) {
                    return <Observable<ToleranceDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ToleranceDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTolerance(response: HttpResponseBase): Observable<ToleranceDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ToleranceDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ToleranceDto[]>(<any>null);
    }

    /**
     * @param toleranceId (optional) 
     * @return Success
     */
    getTolerance(toleranceId: number | null | undefined): Observable<ToleranceDto> {
        let url_ = this.baseUrl + "/api/services/app/Tolerance/GetTolerance?";
        if (toleranceId !== undefined)
            url_ += "toleranceId=" + encodeURIComponent("" + toleranceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetTolerance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTolerance(<any>response_);
                } catch (e) {
                    return <Observable<ToleranceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ToleranceDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTolerance(response: HttpResponseBase): Observable<ToleranceDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ToleranceDto.fromJS(resultData200) : new ToleranceDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ToleranceDto>(<any>null);
    }

    /**
     * @return Success
     */
    getToleranceTree(): Observable<ToleranceTreeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Tolerance/GetToleranceTree";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetToleranceTree(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetToleranceTree(<any>response_);
                } catch (e) {
                    return <Observable<ToleranceTreeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ToleranceTreeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetToleranceTree(response: HttpResponseBase): Observable<ToleranceTreeDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ToleranceTreeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ToleranceTreeDto[]>(<any>null);
    }

    /**
     * @param tolerance (optional) 
     * @return Success
     */
    updateTolerance(tolerance: ToleranceDto | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Tolerance/UpdateTolerance";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tolerance);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateTolerance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTolerance(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTolerance(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

@Injectable()
export class UserIdentityServiceProxy extends ServiceBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    isUserAvailable(input: UserIdentityInput | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/UserIdentity/IsUserAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processIsUserAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsUserAvailable(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processIsUserAvailable(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

export class AddBeamDto implements IAddBeamDto {
    beamName!: string;
    ssd!: number | undefined;
    beamDescription!: string | undefined;
    beamGroupId!: number | undefined;

    constructor(data?: IAddBeamDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.beamName = data["beamName"];
            this.ssd = data["ssd"];
            this.beamDescription = data["beamDescription"];
            this.beamGroupId = data["beamGroupId"];
        }
    }

    static fromJS(data: any): AddBeamDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddBeamDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["beamName"] = this.beamName;
        data["ssd"] = this.ssd;
        data["beamDescription"] = this.beamDescription;
        data["beamGroupId"] = this.beamGroupId;
        return data; 
    }
}

export interface IAddBeamDto {
    beamName: string;
    ssd: number | undefined;
    beamDescription: string | undefined;
    beamGroupId: number | undefined;
}

export class BeamOutput implements IBeamOutput {
    id!: number | undefined;
    beamName!: string | undefined;

    constructor(data?: IBeamOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.beamName = data["beamName"];
        }
    }

    static fromJS(data: any): BeamOutput {
        data = typeof data === 'object' ? data : {};
        let result = new BeamOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["beamName"] = this.beamName;
        return data; 
    }
}

export interface IBeamOutput {
    id: number | undefined;
    beamName: string | undefined;
}

export class BeamDto implements IBeamDto {
    name!: string | undefined;
    number!: number | undefined;
    beamType!: string | undefined;
    beamRadiationType!: string | undefined;
    machineName!: string | undefined;
    description!: string | undefined;
    deviceSerialNumber!: string | undefined;
    beamTreatmentDeliveryType!: TreatmentDeliveryType | undefined;
    rtToleranceTables!: RTToleranceTables | undefined;
    toleranceId!: number | undefined;
    nominalBeamEnergy!: number | undefined;
    beamMu!: number | undefined;
    doseRateSet!: number | undefined;
    beamModes!: BeamMode[] | undefined;
    beamDose!: number | undefined;
    beamFluenceMode!: any | undefined;
    gantryAngle!: number | undefined;
    gantryRotationDirection!: RotationDirection | undefined;
    arcLength!: number | undefined;
    arcStopGantryAngle!: number | undefined;
    patientSupportAngle!: number | undefined;
    mlcLeafPositionBoundaries!: number[] | undefined;
    mlcMovementDirection!: any | undefined;
    collimatorAngle!: number | undefined;
    jawX1!: number | undefined;
    jawX2!: number | undefined;
    jawY1!: number | undefined;
    jawY2!: number | undefined;
    controlPoints!: ControlPointDto[] | undefined;
    rightJawPositionRange!: number[] | undefined;
    leftJawPositionRange!: number[] | undefined;
    topJawPositionRange!: number[] | undefined;
    bottomJawPositionRange!: number[] | undefined;
    portImageBeams!: PortImageBeamDto[] | undefined;
    blockList!: BlockDto[] | undefined;
    wedgeList!: WedgeDto[] | undefined;
    isocenter!: Point3OfDouble | undefined;
    patientSetUp!: PatientSetupDto | undefined;
    isBeamGroupApprove!: boolean | undefined;
    validMachine!: boolean | undefined;
    id!: number | undefined;

    constructor(data?: IBeamDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.number = data["number"];
            this.beamType = data["beamType"];
            this.beamRadiationType = data["beamRadiationType"];
            this.machineName = data["machineName"];
            this.description = data["description"];
            this.deviceSerialNumber = data["deviceSerialNumber"];
            this.beamTreatmentDeliveryType = data["beamTreatmentDeliveryType"] ? TreatmentDeliveryType.fromJS(data["beamTreatmentDeliveryType"]) : <any>undefined;
            this.rtToleranceTables = data["rtToleranceTables"] ? RTToleranceTables.fromJS(data["rtToleranceTables"]) : <any>undefined;
            this.toleranceId = data["toleranceId"];
            this.nominalBeamEnergy = data["nominalBeamEnergy"];
            this.beamMu = data["beamMu"];
            this.doseRateSet = data["doseRateSet"];
            if (data["beamModes"] && data["beamModes"].constructor === Array) {
                this.beamModes = [];
                for (let item of data["beamModes"])
                    this.beamModes.push(BeamMode.fromJS(item));
            }
            this.beamDose = data["beamDose"];
            this.beamFluenceMode = data["beamFluenceMode"];
            this.gantryAngle = data["gantryAngle"];
            this.gantryRotationDirection = data["gantryRotationDirection"] ? RotationDirection.fromJS(data["gantryRotationDirection"]) : <any>undefined;
            this.arcLength = data["arcLength"];
            this.arcStopGantryAngle = data["arcStopGantryAngle"];
            this.patientSupportAngle = data["patientSupportAngle"];
            if (data["mlcLeafPositionBoundaries"] && data["mlcLeafPositionBoundaries"].constructor === Array) {
                this.mlcLeafPositionBoundaries = [];
                for (let item of data["mlcLeafPositionBoundaries"])
                    this.mlcLeafPositionBoundaries.push(item);
            }
            this.mlcMovementDirection = data["mlcMovementDirection"];
            this.collimatorAngle = data["collimatorAngle"];
            this.jawX1 = data["jawX1"];
            this.jawX2 = data["jawX2"];
            this.jawY1 = data["jawY1"];
            this.jawY2 = data["jawY2"];
            if (data["controlPoints"] && data["controlPoints"].constructor === Array) {
                this.controlPoints = [];
                for (let item of data["controlPoints"])
                    this.controlPoints.push(ControlPointDto.fromJS(item));
            }
            if (data["rightJawPositionRange"] && data["rightJawPositionRange"].constructor === Array) {
                this.rightJawPositionRange = [];
                for (let item of data["rightJawPositionRange"])
                    this.rightJawPositionRange.push(item);
            }
            if (data["leftJawPositionRange"] && data["leftJawPositionRange"].constructor === Array) {
                this.leftJawPositionRange = [];
                for (let item of data["leftJawPositionRange"])
                    this.leftJawPositionRange.push(item);
            }
            if (data["topJawPositionRange"] && data["topJawPositionRange"].constructor === Array) {
                this.topJawPositionRange = [];
                for (let item of data["topJawPositionRange"])
                    this.topJawPositionRange.push(item);
            }
            if (data["bottomJawPositionRange"] && data["bottomJawPositionRange"].constructor === Array) {
                this.bottomJawPositionRange = [];
                for (let item of data["bottomJawPositionRange"])
                    this.bottomJawPositionRange.push(item);
            }
            if (data["portImageBeams"] && data["portImageBeams"].constructor === Array) {
                this.portImageBeams = [];
                for (let item of data["portImageBeams"])
                    this.portImageBeams.push(PortImageBeamDto.fromJS(item));
            }
            if (data["blockList"] && data["blockList"].constructor === Array) {
                this.blockList = [];
                for (let item of data["blockList"])
                    this.blockList.push(BlockDto.fromJS(item));
            }
            if (data["wedgeList"] && data["wedgeList"].constructor === Array) {
                this.wedgeList = [];
                for (let item of data["wedgeList"])
                    this.wedgeList.push(WedgeDto.fromJS(item));
            }
            this.isocenter = data["isocenter"] ? Point3OfDouble.fromJS(data["isocenter"]) : <any>undefined;
            this.patientSetUp = data["patientSetUp"] ? PatientSetupDto.fromJS(data["patientSetUp"]) : <any>undefined;
            this.isBeamGroupApprove = data["isBeamGroupApprove"];
            this.validMachine = data["validMachine"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): BeamDto {
        data = typeof data === 'object' ? data : {};
        let result = new BeamDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["number"] = this.number;
        data["beamType"] = this.beamType;
        data["beamRadiationType"] = this.beamRadiationType;
        data["machineName"] = this.machineName;
        data["description"] = this.description;
        data["deviceSerialNumber"] = this.deviceSerialNumber;
        data["beamTreatmentDeliveryType"] = this.beamTreatmentDeliveryType ? this.beamTreatmentDeliveryType.toJSON() : <any>undefined;
        data["rtToleranceTables"] = this.rtToleranceTables ? this.rtToleranceTables.toJSON() : <any>undefined;
        data["toleranceId"] = this.toleranceId;
        data["nominalBeamEnergy"] = this.nominalBeamEnergy;
        data["beamMu"] = this.beamMu;
        data["doseRateSet"] = this.doseRateSet;
        if (this.beamModes && this.beamModes.constructor === Array) {
            data["beamModes"] = [];
            for (let item of this.beamModes)
                data["beamModes"].push(item.toJSON());
        }
        data["beamDose"] = this.beamDose;
        data["beamFluenceMode"] = this.beamFluenceMode;
        data["gantryAngle"] = this.gantryAngle;
        data["gantryRotationDirection"] = this.gantryRotationDirection ? this.gantryRotationDirection.toJSON() : <any>undefined;
        data["arcLength"] = this.arcLength;
        data["arcStopGantryAngle"] = this.arcStopGantryAngle;
        data["patientSupportAngle"] = this.patientSupportAngle;
        if (this.mlcLeafPositionBoundaries && this.mlcLeafPositionBoundaries.constructor === Array) {
            data["mlcLeafPositionBoundaries"] = [];
            for (let item of this.mlcLeafPositionBoundaries)
                data["mlcLeafPositionBoundaries"].push(item);
        }
        data["mlcMovementDirection"] = this.mlcMovementDirection;
        data["collimatorAngle"] = this.collimatorAngle;
        data["jawX1"] = this.jawX1;
        data["jawX2"] = this.jawX2;
        data["jawY1"] = this.jawY1;
        data["jawY2"] = this.jawY2;
        if (this.controlPoints && this.controlPoints.constructor === Array) {
            data["controlPoints"] = [];
            for (let item of this.controlPoints)
                data["controlPoints"].push(item.toJSON());
        }
        if (this.rightJawPositionRange && this.rightJawPositionRange.constructor === Array) {
            data["rightJawPositionRange"] = [];
            for (let item of this.rightJawPositionRange)
                data["rightJawPositionRange"].push(item);
        }
        if (this.leftJawPositionRange && this.leftJawPositionRange.constructor === Array) {
            data["leftJawPositionRange"] = [];
            for (let item of this.leftJawPositionRange)
                data["leftJawPositionRange"].push(item);
        }
        if (this.topJawPositionRange && this.topJawPositionRange.constructor === Array) {
            data["topJawPositionRange"] = [];
            for (let item of this.topJawPositionRange)
                data["topJawPositionRange"].push(item);
        }
        if (this.bottomJawPositionRange && this.bottomJawPositionRange.constructor === Array) {
            data["bottomJawPositionRange"] = [];
            for (let item of this.bottomJawPositionRange)
                data["bottomJawPositionRange"].push(item);
        }
        if (this.portImageBeams && this.portImageBeams.constructor === Array) {
            data["portImageBeams"] = [];
            for (let item of this.portImageBeams)
                data["portImageBeams"].push(item.toJSON());
        }
        if (this.blockList && this.blockList.constructor === Array) {
            data["blockList"] = [];
            for (let item of this.blockList)
                data["blockList"].push(item.toJSON());
        }
        if (this.wedgeList && this.wedgeList.constructor === Array) {
            data["wedgeList"] = [];
            for (let item of this.wedgeList)
                data["wedgeList"].push(item.toJSON());
        }
        data["isocenter"] = this.isocenter ? this.isocenter.toJSON() : <any>undefined;
        data["patientSetUp"] = this.patientSetUp ? this.patientSetUp.toJSON() : <any>undefined;
        data["isBeamGroupApprove"] = this.isBeamGroupApprove;
        data["validMachine"] = this.validMachine;
        data["id"] = this.id;
        return data; 
    }
}

export interface IBeamDto {
    name: string | undefined;
    number: number | undefined;
    beamType: string | undefined;
    beamRadiationType: string | undefined;
    machineName: string | undefined;
    description: string | undefined;
    deviceSerialNumber: string | undefined;
    beamTreatmentDeliveryType: TreatmentDeliveryType | undefined;
    rtToleranceTables: RTToleranceTables | undefined;
    toleranceId: number | undefined;
    nominalBeamEnergy: number | undefined;
    beamMu: number | undefined;
    doseRateSet: number | undefined;
    beamModes: BeamMode[] | undefined;
    beamDose: number | undefined;
    beamFluenceMode: any | undefined;
    gantryAngle: number | undefined;
    gantryRotationDirection: RotationDirection | undefined;
    arcLength: number | undefined;
    arcStopGantryAngle: number | undefined;
    patientSupportAngle: number | undefined;
    mlcLeafPositionBoundaries: number[] | undefined;
    mlcMovementDirection: any | undefined;
    collimatorAngle: number | undefined;
    jawX1: number | undefined;
    jawX2: number | undefined;
    jawY1: number | undefined;
    jawY2: number | undefined;
    controlPoints: ControlPointDto[] | undefined;
    rightJawPositionRange: number[] | undefined;
    leftJawPositionRange: number[] | undefined;
    topJawPositionRange: number[] | undefined;
    bottomJawPositionRange: number[] | undefined;
    portImageBeams: PortImageBeamDto[] | undefined;
    blockList: BlockDto[] | undefined;
    wedgeList: WedgeDto[] | undefined;
    isocenter: Point3OfDouble | undefined;
    patientSetUp: PatientSetupDto | undefined;
    isBeamGroupApprove: boolean | undefined;
    validMachine: boolean | undefined;
    id: number | undefined;
}

export class TreatmentDeliveryType implements ITreatmentDeliveryType {
    name!: string | undefined;
    id!: number | undefined;

    constructor(data?: ITreatmentDeliveryType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TreatmentDeliveryType {
        data = typeof data === 'object' ? data : {};
        let result = new TreatmentDeliveryType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITreatmentDeliveryType {
    name: string | undefined;
    id: number | undefined;
}

export class RTToleranceTables implements IRTToleranceTables {
    toleranceTableNumber!: number | undefined;
    toleranceTableLabel!: string | undefined;
    gantryAngleTolerance!: number | undefined;
    beamLimitingDeviceAngleTolerance!: number | undefined;
    patientSupportAngleTolerance!: number | undefined;
    tableTopVerticalPositionTolerance!: number | undefined;
    tableTopLongitudinalPositionTolerance!: number | undefined;
    tableTopLateralPositionTolerance!: number | undefined;
    beamLimitingDeviceToleranceSequence!: BeamLimitingDeviceTolerance[] | undefined;

    constructor(data?: IRTToleranceTables) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.toleranceTableNumber = data["toleranceTableNumber"];
            this.toleranceTableLabel = data["toleranceTableLabel"];
            this.gantryAngleTolerance = data["gantryAngleTolerance"];
            this.beamLimitingDeviceAngleTolerance = data["beamLimitingDeviceAngleTolerance"];
            this.patientSupportAngleTolerance = data["patientSupportAngleTolerance"];
            this.tableTopVerticalPositionTolerance = data["tableTopVerticalPositionTolerance"];
            this.tableTopLongitudinalPositionTolerance = data["tableTopLongitudinalPositionTolerance"];
            this.tableTopLateralPositionTolerance = data["tableTopLateralPositionTolerance"];
            if (data["beamLimitingDeviceToleranceSequence"] && data["beamLimitingDeviceToleranceSequence"].constructor === Array) {
                this.beamLimitingDeviceToleranceSequence = [];
                for (let item of data["beamLimitingDeviceToleranceSequence"])
                    this.beamLimitingDeviceToleranceSequence.push(BeamLimitingDeviceTolerance.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RTToleranceTables {
        data = typeof data === 'object' ? data : {};
        let result = new RTToleranceTables();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["toleranceTableNumber"] = this.toleranceTableNumber;
        data["toleranceTableLabel"] = this.toleranceTableLabel;
        data["gantryAngleTolerance"] = this.gantryAngleTolerance;
        data["beamLimitingDeviceAngleTolerance"] = this.beamLimitingDeviceAngleTolerance;
        data["patientSupportAngleTolerance"] = this.patientSupportAngleTolerance;
        data["tableTopVerticalPositionTolerance"] = this.tableTopVerticalPositionTolerance;
        data["tableTopLongitudinalPositionTolerance"] = this.tableTopLongitudinalPositionTolerance;
        data["tableTopLateralPositionTolerance"] = this.tableTopLateralPositionTolerance;
        if (this.beamLimitingDeviceToleranceSequence && this.beamLimitingDeviceToleranceSequence.constructor === Array) {
            data["beamLimitingDeviceToleranceSequence"] = [];
            for (let item of this.beamLimitingDeviceToleranceSequence)
                data["beamLimitingDeviceToleranceSequence"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IRTToleranceTables {
    toleranceTableNumber: number | undefined;
    toleranceTableLabel: string | undefined;
    gantryAngleTolerance: number | undefined;
    beamLimitingDeviceAngleTolerance: number | undefined;
    patientSupportAngleTolerance: number | undefined;
    tableTopVerticalPositionTolerance: number | undefined;
    tableTopLongitudinalPositionTolerance: number | undefined;
    tableTopLateralPositionTolerance: number | undefined;
    beamLimitingDeviceToleranceSequence: BeamLimitingDeviceTolerance[] | undefined;
}

export class BeamMode implements IBeamMode {
    energy!: number | undefined;
    isFlattened!: boolean | undefined;
    doseRates!: number[] | undefined;

    constructor(data?: IBeamMode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.energy = data["energy"];
            this.isFlattened = data["isFlattened"];
            if (data["doseRates"] && data["doseRates"].constructor === Array) {
                this.doseRates = [];
                for (let item of data["doseRates"])
                    this.doseRates.push(item);
            }
        }
    }

    static fromJS(data: any): BeamMode {
        data = typeof data === 'object' ? data : {};
        let result = new BeamMode();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["energy"] = this.energy;
        data["isFlattened"] = this.isFlattened;
        if (this.doseRates && this.doseRates.constructor === Array) {
            data["doseRates"] = [];
            for (let item of this.doseRates)
                data["doseRates"].push(item);
        }
        return data; 
    }
}

export interface IBeamMode {
    energy: number | undefined;
    isFlattened: boolean | undefined;
    doseRates: number[] | undefined;
}

export class RotationDirection implements IRotationDirection {
    name!: string | undefined;
    id!: number | undefined;

    constructor(data?: IRotationDirection) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RotationDirection {
        data = typeof data === 'object' ? data : {};
        let result = new RotationDirection();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data; 
    }
}

export interface IRotationDirection {
    name: string | undefined;
    id: number | undefined;
}

export class ControlPointDto implements IControlPointDto {
    controlPointIndex!: number | undefined;
    doseRateSet!: number | undefined;
    jaw_X1!: number | undefined;
    jaw_X2!: number | undefined;
    jaw_Y1!: number | undefined;
    jaw_Y2!: number | undefined;
    asymX!: boolean | undefined;
    asymY!: boolean | undefined;
    leafPositions!: number[][] | undefined;
    gantryAngle!: number | undefined;
    gantryRotationDirection!: RotationDirection | undefined;
    beamLimitingDeviceAngle!: number | undefined;
    beamLimitingDeviceRotationDirection!: RotationDirection | undefined;
    patientSupportAngle!: number | undefined;
    patientSupportRotationDirection!: RotationDirection | undefined;
    tableTopEccentricAngle!: number | undefined;
    tableTopEccentricRotationDirection!: RotationDirection | undefined;
    tableTopVerticalPosition!: number | undefined;
    tableTopLongitudinalPosition!: number | undefined;
    tableTopLateralPosition!: number | undefined;
    cumulativeMetersetWeight!: number | undefined;
    sourceToSurfaceDistance!: number | undefined;
    isoCenterPosition!: Point3OfDouble | undefined;
    beamId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IControlPointDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.controlPointIndex = data["controlPointIndex"];
            this.doseRateSet = data["doseRateSet"];
            this.jaw_X1 = data["jaw_X1"];
            this.jaw_X2 = data["jaw_X2"];
            this.jaw_Y1 = data["jaw_Y1"];
            this.jaw_Y2 = data["jaw_Y2"];
            this.asymX = data["asymX"];
            this.asymY = data["asymY"];
            if (data["leafPositions"] && data["leafPositions"].constructor === Array) {
                this.leafPositions = [];
                for (let item of data["leafPositions"])
                    this.leafPositions.push(item);
            }
            this.gantryAngle = data["gantryAngle"];
            this.gantryRotationDirection = data["gantryRotationDirection"] ? RotationDirection.fromJS(data["gantryRotationDirection"]) : <any>undefined;
            this.beamLimitingDeviceAngle = data["beamLimitingDeviceAngle"];
            this.beamLimitingDeviceRotationDirection = data["beamLimitingDeviceRotationDirection"] ? RotationDirection.fromJS(data["beamLimitingDeviceRotationDirection"]) : <any>undefined;
            this.patientSupportAngle = data["patientSupportAngle"];
            this.patientSupportRotationDirection = data["patientSupportRotationDirection"] ? RotationDirection.fromJS(data["patientSupportRotationDirection"]) : <any>undefined;
            this.tableTopEccentricAngle = data["tableTopEccentricAngle"];
            this.tableTopEccentricRotationDirection = data["tableTopEccentricRotationDirection"] ? RotationDirection.fromJS(data["tableTopEccentricRotationDirection"]) : <any>undefined;
            this.tableTopVerticalPosition = data["tableTopVerticalPosition"];
            this.tableTopLongitudinalPosition = data["tableTopLongitudinalPosition"];
            this.tableTopLateralPosition = data["tableTopLateralPosition"];
            this.cumulativeMetersetWeight = data["cumulativeMetersetWeight"];
            this.sourceToSurfaceDistance = data["sourceToSurfaceDistance"];
            this.isoCenterPosition = data["isoCenterPosition"] ? Point3OfDouble.fromJS(data["isoCenterPosition"]) : <any>undefined;
            this.beamId = data["beamId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ControlPointDto {
        data = typeof data === 'object' ? data : {};
        let result = new ControlPointDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["controlPointIndex"] = this.controlPointIndex;
        data["doseRateSet"] = this.doseRateSet;
        data["jaw_X1"] = this.jaw_X1;
        data["jaw_X2"] = this.jaw_X2;
        data["jaw_Y1"] = this.jaw_Y1;
        data["jaw_Y2"] = this.jaw_Y2;
        data["asymX"] = this.asymX;
        data["asymY"] = this.asymY;
        if (this.leafPositions && this.leafPositions.constructor === Array) {
            data["leafPositions"] = [];
            for (let item of this.leafPositions)
                data["leafPositions"].push(item);
        }
        data["gantryAngle"] = this.gantryAngle;
        data["gantryRotationDirection"] = this.gantryRotationDirection ? this.gantryRotationDirection.toJSON() : <any>undefined;
        data["beamLimitingDeviceAngle"] = this.beamLimitingDeviceAngle;
        data["beamLimitingDeviceRotationDirection"] = this.beamLimitingDeviceRotationDirection ? this.beamLimitingDeviceRotationDirection.toJSON() : <any>undefined;
        data["patientSupportAngle"] = this.patientSupportAngle;
        data["patientSupportRotationDirection"] = this.patientSupportRotationDirection ? this.patientSupportRotationDirection.toJSON() : <any>undefined;
        data["tableTopEccentricAngle"] = this.tableTopEccentricAngle;
        data["tableTopEccentricRotationDirection"] = this.tableTopEccentricRotationDirection ? this.tableTopEccentricRotationDirection.toJSON() : <any>undefined;
        data["tableTopVerticalPosition"] = this.tableTopVerticalPosition;
        data["tableTopLongitudinalPosition"] = this.tableTopLongitudinalPosition;
        data["tableTopLateralPosition"] = this.tableTopLateralPosition;
        data["cumulativeMetersetWeight"] = this.cumulativeMetersetWeight;
        data["sourceToSurfaceDistance"] = this.sourceToSurfaceDistance;
        data["isoCenterPosition"] = this.isoCenterPosition ? this.isoCenterPosition.toJSON() : <any>undefined;
        data["beamId"] = this.beamId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IControlPointDto {
    controlPointIndex: number | undefined;
    doseRateSet: number | undefined;
    jaw_X1: number | undefined;
    jaw_X2: number | undefined;
    jaw_Y1: number | undefined;
    jaw_Y2: number | undefined;
    asymX: boolean | undefined;
    asymY: boolean | undefined;
    leafPositions: number[][] | undefined;
    gantryAngle: number | undefined;
    gantryRotationDirection: RotationDirection | undefined;
    beamLimitingDeviceAngle: number | undefined;
    beamLimitingDeviceRotationDirection: RotationDirection | undefined;
    patientSupportAngle: number | undefined;
    patientSupportRotationDirection: RotationDirection | undefined;
    tableTopEccentricAngle: number | undefined;
    tableTopEccentricRotationDirection: RotationDirection | undefined;
    tableTopVerticalPosition: number | undefined;
    tableTopLongitudinalPosition: number | undefined;
    tableTopLateralPosition: number | undefined;
    cumulativeMetersetWeight: number | undefined;
    sourceToSurfaceDistance: number | undefined;
    isoCenterPosition: Point3OfDouble | undefined;
    beamId: number | undefined;
    id: number | undefined;
}

export class PortImageBeamDto implements IPortImageBeamDto {
    referencedTreatmentBeamId!: number | undefined;
    portType!: PortalImageTypes | undefined;
    detectorBinningMode!: number | undefined;
    sid!: number | undefined;
    detectorXShift!: number | undefined;
    detectorYShift!: number | undefined;
    pixelSpacing!: number | undefined;
    sliceDimensionWidthInPixelNumber!: number | undefined;
    sliceDimensionHightInPixelNumber!: number | undefined;
    doublePosure!: PortalExposureTypes | undefined;
    portImageOpenMu!: number | undefined;
    portImageDelta!: number | undefined;
    mu!: number | undefined;
    detectorGain!: number | undefined;
    isFlat!: boolean | undefined;
    radiationType!: RadiationType | undefined;
    machineEnergy!: number | undefined;
    id!: number | undefined;

    constructor(data?: IPortImageBeamDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.referencedTreatmentBeamId = data["referencedTreatmentBeamId"];
            this.portType = data["portType"] ? PortalImageTypes.fromJS(data["portType"]) : <any>undefined;
            this.detectorBinningMode = data["detectorBinningMode"];
            this.sid = data["sid"];
            this.detectorXShift = data["detectorXShift"];
            this.detectorYShift = data["detectorYShift"];
            this.pixelSpacing = data["pixelSpacing"];
            this.sliceDimensionWidthInPixelNumber = data["sliceDimensionWidthInPixelNumber"];
            this.sliceDimensionHightInPixelNumber = data["sliceDimensionHightInPixelNumber"];
            this.doublePosure = data["doublePosure"] ? PortalExposureTypes.fromJS(data["doublePosure"]) : <any>undefined;
            this.portImageOpenMu = data["portImageOpenMu"];
            this.portImageDelta = data["portImageDelta"];
            this.mu = data["mu"];
            this.detectorGain = data["detectorGain"];
            this.isFlat = data["isFlat"];
            this.radiationType = data["radiationType"] ? RadiationType.fromJS(data["radiationType"]) : <any>undefined;
            this.machineEnergy = data["machineEnergy"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PortImageBeamDto {
        data = typeof data === 'object' ? data : {};
        let result = new PortImageBeamDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["referencedTreatmentBeamId"] = this.referencedTreatmentBeamId;
        data["portType"] = this.portType ? this.portType.toJSON() : <any>undefined;
        data["detectorBinningMode"] = this.detectorBinningMode;
        data["sid"] = this.sid;
        data["detectorXShift"] = this.detectorXShift;
        data["detectorYShift"] = this.detectorYShift;
        data["pixelSpacing"] = this.pixelSpacing;
        data["sliceDimensionWidthInPixelNumber"] = this.sliceDimensionWidthInPixelNumber;
        data["sliceDimensionHightInPixelNumber"] = this.sliceDimensionHightInPixelNumber;
        data["doublePosure"] = this.doublePosure ? this.doublePosure.toJSON() : <any>undefined;
        data["portImageOpenMu"] = this.portImageOpenMu;
        data["portImageDelta"] = this.portImageDelta;
        data["mu"] = this.mu;
        data["detectorGain"] = this.detectorGain;
        data["isFlat"] = this.isFlat;
        data["radiationType"] = this.radiationType ? this.radiationType.toJSON() : <any>undefined;
        data["machineEnergy"] = this.machineEnergy;
        data["id"] = this.id;
        return data; 
    }
}

export interface IPortImageBeamDto {
    referencedTreatmentBeamId: number | undefined;
    portType: PortalImageTypes | undefined;
    detectorBinningMode: number | undefined;
    sid: number | undefined;
    detectorXShift: number | undefined;
    detectorYShift: number | undefined;
    pixelSpacing: number | undefined;
    sliceDimensionWidthInPixelNumber: number | undefined;
    sliceDimensionHightInPixelNumber: number | undefined;
    doublePosure: PortalExposureTypes | undefined;
    portImageOpenMu: number | undefined;
    portImageDelta: number | undefined;
    mu: number | undefined;
    detectorGain: number | undefined;
    isFlat: boolean | undefined;
    radiationType: RadiationType | undefined;
    machineEnergy: number | undefined;
    id: number | undefined;
}

export class BlockDto implements IBlockDto {
    blockTrayID!: string | undefined;
    sourceToBlockTrayDistance!: number | undefined;
    blockType!: any | undefined;
    blockDivergence!: any | undefined;
    blockMountingPosition!: any | undefined;
    blockNumber!: number | undefined;
    blockName!: string | undefined;
    blockThickness!: number | undefined;
    blockTransmission!: number | undefined;
    blockNumberOfPoints!: number | undefined;
    blockData!: number[] | undefined;

    constructor(data?: IBlockDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.blockTrayID = data["blockTrayID"];
            this.sourceToBlockTrayDistance = data["sourceToBlockTrayDistance"];
            this.blockType = data["blockType"];
            this.blockDivergence = data["blockDivergence"];
            this.blockMountingPosition = data["blockMountingPosition"];
            this.blockNumber = data["blockNumber"];
            this.blockName = data["blockName"];
            this.blockThickness = data["blockThickness"];
            this.blockTransmission = data["blockTransmission"];
            this.blockNumberOfPoints = data["blockNumberOfPoints"];
            if (data["blockData"] && data["blockData"].constructor === Array) {
                this.blockData = [];
                for (let item of data["blockData"])
                    this.blockData.push(item);
            }
        }
    }

    static fromJS(data: any): BlockDto {
        data = typeof data === 'object' ? data : {};
        let result = new BlockDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["blockTrayID"] = this.blockTrayID;
        data["sourceToBlockTrayDistance"] = this.sourceToBlockTrayDistance;
        data["blockType"] = this.blockType;
        data["blockDivergence"] = this.blockDivergence;
        data["blockMountingPosition"] = this.blockMountingPosition;
        data["blockNumber"] = this.blockNumber;
        data["blockName"] = this.blockName;
        data["blockThickness"] = this.blockThickness;
        data["blockTransmission"] = this.blockTransmission;
        data["blockNumberOfPoints"] = this.blockNumberOfPoints;
        if (this.blockData && this.blockData.constructor === Array) {
            data["blockData"] = [];
            for (let item of this.blockData)
                data["blockData"].push(item);
        }
        return data; 
    }
}

export interface IBlockDto {
    blockTrayID: string | undefined;
    sourceToBlockTrayDistance: number | undefined;
    blockType: any | undefined;
    blockDivergence: any | undefined;
    blockMountingPosition: any | undefined;
    blockNumber: number | undefined;
    blockName: string | undefined;
    blockThickness: number | undefined;
    blockTransmission: number | undefined;
    blockNumberOfPoints: number | undefined;
    blockData: number[] | undefined;
}

export class WedgeDto implements IWedgeDto {
    wedgeNumber!: number | undefined;
    wedgeType!: any | undefined;
    wedgeID!: string | undefined;
    wedgeAngle!: number | undefined;
    wedgeFactor!: number | undefined;
    wedgeOrientation!: number | undefined;
    sourceToWedgeTrayDistance!: number | undefined;
    effectiveWedgeAngle!: number | undefined;

    constructor(data?: IWedgeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wedgeNumber = data["wedgeNumber"];
            this.wedgeType = data["wedgeType"];
            this.wedgeID = data["wedgeID"];
            this.wedgeAngle = data["wedgeAngle"];
            this.wedgeFactor = data["wedgeFactor"];
            this.wedgeOrientation = data["wedgeOrientation"];
            this.sourceToWedgeTrayDistance = data["sourceToWedgeTrayDistance"];
            this.effectiveWedgeAngle = data["effectiveWedgeAngle"];
        }
    }

    static fromJS(data: any): WedgeDto {
        data = typeof data === 'object' ? data : {};
        let result = new WedgeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wedgeNumber"] = this.wedgeNumber;
        data["wedgeType"] = this.wedgeType;
        data["wedgeID"] = this.wedgeID;
        data["wedgeAngle"] = this.wedgeAngle;
        data["wedgeFactor"] = this.wedgeFactor;
        data["wedgeOrientation"] = this.wedgeOrientation;
        data["sourceToWedgeTrayDistance"] = this.sourceToWedgeTrayDistance;
        data["effectiveWedgeAngle"] = this.effectiveWedgeAngle;
        return data; 
    }
}

export interface IWedgeDto {
    wedgeNumber: number | undefined;
    wedgeType: any | undefined;
    wedgeID: string | undefined;
    wedgeAngle: number | undefined;
    wedgeFactor: number | undefined;
    wedgeOrientation: number | undefined;
    sourceToWedgeTrayDistance: number | undefined;
    effectiveWedgeAngle: number | undefined;
}

export class Point3OfDouble implements IPoint3OfDouble {
    x!: number | undefined;
    y!: number | undefined;
    z!: number | undefined;

    constructor(data?: IPoint3OfDouble) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.x = data["x"];
            this.y = data["y"];
            this.z = data["z"];
        }
    }

    static fromJS(data: any): Point3OfDouble {
        data = typeof data === 'object' ? data : {};
        let result = new Point3OfDouble();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["x"] = this.x;
        data["y"] = this.y;
        data["z"] = this.z;
        return data; 
    }
}

export interface IPoint3OfDouble {
    x: number | undefined;
    y: number | undefined;
    z: number | undefined;
}

export class PatientSetupDto implements IPatientSetupDto {
    patientSetupNumber!: number | undefined;
    patientPosition!: PatientPosition | undefined;
    tableTopVerticalSetupDisplacement!: number | undefined;
    tableTopLongitudinalSetupDisplacement!: number | undefined;
    tableTopLateralSetupDisplacement!: number | undefined;

    constructor(data?: IPatientSetupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.patientSetupNumber = data["patientSetupNumber"];
            this.patientPosition = data["patientPosition"] ? PatientPosition.fromJS(data["patientPosition"]) : <any>undefined;
            this.tableTopVerticalSetupDisplacement = data["tableTopVerticalSetupDisplacement"];
            this.tableTopLongitudinalSetupDisplacement = data["tableTopLongitudinalSetupDisplacement"];
            this.tableTopLateralSetupDisplacement = data["tableTopLateralSetupDisplacement"];
        }
    }

    static fromJS(data: any): PatientSetupDto {
        data = typeof data === 'object' ? data : {};
        let result = new PatientSetupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["patientSetupNumber"] = this.patientSetupNumber;
        data["patientPosition"] = this.patientPosition ? this.patientPosition.toJSON() : <any>undefined;
        data["tableTopVerticalSetupDisplacement"] = this.tableTopVerticalSetupDisplacement;
        data["tableTopLongitudinalSetupDisplacement"] = this.tableTopLongitudinalSetupDisplacement;
        data["tableTopLateralSetupDisplacement"] = this.tableTopLateralSetupDisplacement;
        return data; 
    }
}

export interface IPatientSetupDto {
    patientSetupNumber: number | undefined;
    patientPosition: PatientPosition | undefined;
    tableTopVerticalSetupDisplacement: number | undefined;
    tableTopLongitudinalSetupDisplacement: number | undefined;
    tableTopLateralSetupDisplacement: number | undefined;
}

export class BeamLimitingDeviceTolerance implements IBeamLimitingDeviceTolerance {
    beamLimitingDeviceType!: string | undefined;
    beamLimitingDevicePositionTolerance!: number | undefined;

    constructor(data?: IBeamLimitingDeviceTolerance) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.beamLimitingDeviceType = data["beamLimitingDeviceType"];
            this.beamLimitingDevicePositionTolerance = data["beamLimitingDevicePositionTolerance"];
        }
    }

    static fromJS(data: any): BeamLimitingDeviceTolerance {
        data = typeof data === 'object' ? data : {};
        let result = new BeamLimitingDeviceTolerance();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["beamLimitingDeviceType"] = this.beamLimitingDeviceType;
        data["beamLimitingDevicePositionTolerance"] = this.beamLimitingDevicePositionTolerance;
        return data; 
    }
}

export interface IBeamLimitingDeviceTolerance {
    beamLimitingDeviceType: string | undefined;
    beamLimitingDevicePositionTolerance: number | undefined;
}

export class PortalImageTypes implements IPortalImageTypes {
    name!: string | undefined;
    id!: number | undefined;

    constructor(data?: IPortalImageTypes) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PortalImageTypes {
        data = typeof data === 'object' ? data : {};
        let result = new PortalImageTypes();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data; 
    }
}

export interface IPortalImageTypes {
    name: string | undefined;
    id: number | undefined;
}

export class PortalExposureTypes implements IPortalExposureTypes {
    name!: string | undefined;
    id!: number | undefined;

    constructor(data?: IPortalExposureTypes) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PortalExposureTypes {
        data = typeof data === 'object' ? data : {};
        let result = new PortalExposureTypes();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data; 
    }
}

export interface IPortalExposureTypes {
    name: string | undefined;
    id: number | undefined;
}

export class RadiationType implements IRadiationType {
    name!: string | undefined;
    id!: number | undefined;

    constructor(data?: IRadiationType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RadiationType {
        data = typeof data === 'object' ? data : {};
        let result = new RadiationType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data; 
    }
}

export interface IRadiationType {
    name: string | undefined;
    id: number | undefined;
}

export class PatientPosition implements IPatientPosition {
    name!: string | undefined;
    id!: number | undefined;

    constructor(data?: IPatientPosition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PatientPosition {
        data = typeof data === 'object' ? data : {};
        let result = new PatientPosition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data; 
    }
}

export interface IPatientPosition {
    name: string | undefined;
    id: number | undefined;
}

export class CopyBeamDto implements ICopyBeamDto {
    beamName!: string;
    copyBeamId!: number | undefined;

    constructor(data?: ICopyBeamDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.beamName = data["beamName"];
            this.copyBeamId = data["copyBeamId"];
        }
    }

    static fromJS(data: any): CopyBeamDto {
        data = typeof data === 'object' ? data : {};
        let result = new CopyBeamDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["beamName"] = this.beamName;
        data["copyBeamId"] = this.copyBeamId;
        return data; 
    }
}

export interface ICopyBeamDto {
    beamName: string;
    copyBeamId: number | undefined;
}

export class AddBeamGroupDto implements IAddBeamGroupDto {
    name!: string | undefined;
    description!: string | undefined;
    radiationType!: number | undefined;
    techniqueType!: number | undefined;
    machineName!: string | undefined;
    patientId!: number | undefined;
    toleranceId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IAddBeamGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.description = data["description"];
            this.radiationType = data["radiationType"];
            this.techniqueType = data["techniqueType"];
            this.machineName = data["machineName"];
            this.patientId = data["patientId"];
            this.toleranceId = data["toleranceId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AddBeamGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddBeamGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["radiationType"] = this.radiationType;
        data["techniqueType"] = this.techniqueType;
        data["machineName"] = this.machineName;
        data["patientId"] = this.patientId;
        data["toleranceId"] = this.toleranceId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAddBeamGroupDto {
    name: string | undefined;
    description: string | undefined;
    radiationType: number | undefined;
    techniqueType: number | undefined;
    machineName: string | undefined;
    patientId: number | undefined;
    toleranceId: number | undefined;
    id: number | undefined;
}

export class BeamGroupDto implements IBeamGroupDto {
    name!: string | undefined;
    machineName!: string | undefined;
    radiationType!: RadiationType | undefined;
    techniqueType!: TechniqueType | undefined;
    description!: string | undefined;
    fractionDose!: number | undefined;
    fractionNumber!: number | undefined;
    totalDose!: number | undefined;
    targetDescription!: string | undefined;
    isApproved!: boolean | undefined;
    approver!: string | undefined;
    approveDate!: string | undefined;
    isActive!: boolean | undefined;
    isCheck!: boolean | undefined;
    isCreateByTms!: boolean | undefined;
    isMachineValide!: boolean | undefined;
    toleranceId!: number | undefined;
    planId!: number | undefined;
    completedSessionNum!: number | undefined;
    relatedPrescriptionId!: number | undefined;
    relatedRx!: PresciprionOutput | undefined;
    setupList!: SetupDto[] | undefined;
    beams!: BeamDto[] | undefined;
    images!: BeamGroupImageDto[] | undefined;
    deleteImages!: BeamGroupImageDto[] | undefined;
    fixationDeviceImgList!: FixationDeviceImageDto[] | undefined;
    deletedFixationDeviceImgList!: FixationDeviceImageDto[] | undefined;
    isGating!: boolean | undefined;
    gatingModel!: number | undefined;
    id!: number | undefined;

    constructor(data?: IBeamGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.machineName = data["machineName"];
            this.radiationType = data["radiationType"] ? RadiationType.fromJS(data["radiationType"]) : <any>undefined;
            this.techniqueType = data["techniqueType"] ? TechniqueType.fromJS(data["techniqueType"]) : <any>undefined;
            this.description = data["description"];
            this.fractionDose = data["fractionDose"];
            this.fractionNumber = data["fractionNumber"];
            this.totalDose = data["totalDose"];
            this.targetDescription = data["targetDescription"];
            this.isApproved = data["isApproved"];
            this.approver = data["approver"];
            this.approveDate = data["approveDate"];
            this.isActive = data["isActive"];
            this.isCheck = data["isCheck"];
            this.isCreateByTms = data["isCreateByTms"];
            this.isMachineValide = data["isMachineValide"];
            this.toleranceId = data["toleranceId"];
            this.planId = data["planId"];
            this.completedSessionNum = data["completedSessionNum"];
            this.relatedPrescriptionId = data["relatedPrescriptionId"];
            this.relatedRx = data["relatedRx"] ? PresciprionOutput.fromJS(data["relatedRx"]) : <any>undefined;
            if (data["setupList"] && data["setupList"].constructor === Array) {
                this.setupList = [];
                for (let item of data["setupList"])
                    this.setupList.push(SetupDto.fromJS(item));
            }
            if (data["beams"] && data["beams"].constructor === Array) {
                this.beams = [];
                for (let item of data["beams"])
                    this.beams.push(BeamDto.fromJS(item));
            }
            if (data["images"] && data["images"].constructor === Array) {
                this.images = [];
                for (let item of data["images"])
                    this.images.push(BeamGroupImageDto.fromJS(item));
            }
            if (data["deleteImages"] && data["deleteImages"].constructor === Array) {
                this.deleteImages = [];
                for (let item of data["deleteImages"])
                    this.deleteImages.push(BeamGroupImageDto.fromJS(item));
            }
            if (data["fixationDeviceImgList"] && data["fixationDeviceImgList"].constructor === Array) {
                this.fixationDeviceImgList = [];
                for (let item of data["fixationDeviceImgList"])
                    this.fixationDeviceImgList.push(FixationDeviceImageDto.fromJS(item));
            }
            if (data["deletedFixationDeviceImgList"] && data["deletedFixationDeviceImgList"].constructor === Array) {
                this.deletedFixationDeviceImgList = [];
                for (let item of data["deletedFixationDeviceImgList"])
                    this.deletedFixationDeviceImgList.push(FixationDeviceImageDto.fromJS(item));
            }
            this.isGating = data["isGating"];
            this.gatingModel = data["gatingModel"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): BeamGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new BeamGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["machineName"] = this.machineName;
        data["radiationType"] = this.radiationType ? this.radiationType.toJSON() : <any>undefined;
        data["techniqueType"] = this.techniqueType ? this.techniqueType.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["fractionDose"] = this.fractionDose;
        data["fractionNumber"] = this.fractionNumber;
        data["totalDose"] = this.totalDose;
        data["targetDescription"] = this.targetDescription;
        data["isApproved"] = this.isApproved;
        data["approver"] = this.approver;
        data["approveDate"] = this.approveDate;
        data["isActive"] = this.isActive;
        data["isCheck"] = this.isCheck;
        data["isCreateByTms"] = this.isCreateByTms;
        data["isMachineValide"] = this.isMachineValide;
        data["toleranceId"] = this.toleranceId;
        data["planId"] = this.planId;
        data["completedSessionNum"] = this.completedSessionNum;
        data["relatedPrescriptionId"] = this.relatedPrescriptionId;
        data["relatedRx"] = this.relatedRx ? this.relatedRx.toJSON() : <any>undefined;
        if (this.setupList && this.setupList.constructor === Array) {
            data["setupList"] = [];
            for (let item of this.setupList)
                data["setupList"].push(item.toJSON());
        }
        if (this.beams && this.beams.constructor === Array) {
            data["beams"] = [];
            for (let item of this.beams)
                data["beams"].push(item.toJSON());
        }
        if (this.images && this.images.constructor === Array) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item.toJSON());
        }
        if (this.deleteImages && this.deleteImages.constructor === Array) {
            data["deleteImages"] = [];
            for (let item of this.deleteImages)
                data["deleteImages"].push(item.toJSON());
        }
        if (this.fixationDeviceImgList && this.fixationDeviceImgList.constructor === Array) {
            data["fixationDeviceImgList"] = [];
            for (let item of this.fixationDeviceImgList)
                data["fixationDeviceImgList"].push(item.toJSON());
        }
        if (this.deletedFixationDeviceImgList && this.deletedFixationDeviceImgList.constructor === Array) {
            data["deletedFixationDeviceImgList"] = [];
            for (let item of this.deletedFixationDeviceImgList)
                data["deletedFixationDeviceImgList"].push(item.toJSON());
        }
        data["isGating"] = this.isGating;
        data["gatingModel"] = this.gatingModel;
        data["id"] = this.id;
        return data; 
    }
}

export interface IBeamGroupDto {
    name: string | undefined;
    machineName: string | undefined;
    radiationType: RadiationType | undefined;
    techniqueType: TechniqueType | undefined;
    description: string | undefined;
    fractionDose: number | undefined;
    fractionNumber: number | undefined;
    totalDose: number | undefined;
    targetDescription: string | undefined;
    isApproved: boolean | undefined;
    approver: string | undefined;
    approveDate: string | undefined;
    isActive: boolean | undefined;
    isCheck: boolean | undefined;
    isCreateByTms: boolean | undefined;
    isMachineValide: boolean | undefined;
    toleranceId: number | undefined;
    planId: number | undefined;
    completedSessionNum: number | undefined;
    relatedPrescriptionId: number | undefined;
    relatedRx: PresciprionOutput | undefined;
    setupList: SetupDto[] | undefined;
    beams: BeamDto[] | undefined;
    images: BeamGroupImageDto[] | undefined;
    deleteImages: BeamGroupImageDto[] | undefined;
    fixationDeviceImgList: FixationDeviceImageDto[] | undefined;
    deletedFixationDeviceImgList: FixationDeviceImageDto[] | undefined;
    isGating: boolean | undefined;
    gatingModel: number | undefined;
    id: number | undefined;
}

export class TechniqueType implements ITechniqueType {
    name!: string | undefined;
    id!: number | undefined;

    constructor(data?: ITechniqueType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TechniqueType {
        data = typeof data === 'object' ? data : {};
        let result = new TechniqueType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITechniqueType {
    name: string | undefined;
    id: number | undefined;
}

export class PresciprionOutput implements IPresciprionOutput {
    index!: number | undefined;
    siteName!: string | undefined;
    rxDescription!: string | undefined;
    radiationType!: string | undefined;
    techniqueType!: string | undefined;
    target!: string | undefined;
    courseName!: string | undefined;

    constructor(data?: IPresciprionOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.index = data["index"];
            this.siteName = data["siteName"];
            this.rxDescription = data["rxDescription"];
            this.radiationType = data["radiationType"];
            this.techniqueType = data["techniqueType"];
            this.target = data["target"];
            this.courseName = data["courseName"];
        }
    }

    static fromJS(data: any): PresciprionOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PresciprionOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["index"] = this.index;
        data["siteName"] = this.siteName;
        data["rxDescription"] = this.rxDescription;
        data["radiationType"] = this.radiationType;
        data["techniqueType"] = this.techniqueType;
        data["target"] = this.target;
        data["courseName"] = this.courseName;
        return data; 
    }
}

export interface IPresciprionOutput {
    index: number | undefined;
    siteName: string | undefined;
    rxDescription: string | undefined;
    radiationType: string | undefined;
    techniqueType: string | undefined;
    target: string | undefined;
    courseName: string | undefined;
}

export class SetupDto implements ISetupDto {
    id!: number | undefined;
    patientSetupNumber!: number | undefined;
    patientPosition!: PatientPosition | undefined;
    patientSetupLable!: string | undefined;
    patientAdditionalPosition!: string | undefined;
    refToleranceTableId!: number | undefined;

    constructor(data?: ISetupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.patientSetupNumber = data["patientSetupNumber"];
            this.patientPosition = data["patientPosition"] ? PatientPosition.fromJS(data["patientPosition"]) : <any>undefined;
            this.patientSetupLable = data["patientSetupLable"];
            this.patientAdditionalPosition = data["patientAdditionalPosition"];
            this.refToleranceTableId = data["refToleranceTableId"];
        }
    }

    static fromJS(data: any): SetupDto {
        data = typeof data === 'object' ? data : {};
        let result = new SetupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["patientSetupNumber"] = this.patientSetupNumber;
        data["patientPosition"] = this.patientPosition ? this.patientPosition.toJSON() : <any>undefined;
        data["patientSetupLable"] = this.patientSetupLable;
        data["patientAdditionalPosition"] = this.patientAdditionalPosition;
        data["refToleranceTableId"] = this.refToleranceTableId;
        return data; 
    }
}

export interface ISetupDto {
    id: number | undefined;
    patientSetupNumber: number | undefined;
    patientPosition: PatientPosition | undefined;
    patientSetupLable: string | undefined;
    patientAdditionalPosition: string | undefined;
    refToleranceTableId: number | undefined;
}

export class BeamGroupImageDto implements IBeamGroupImageDto {
    id!: number | undefined;
    beamGroupId!: number | undefined;
    imageFilePath!: string | undefined;
    imageName!: string | undefined;

    constructor(data?: IBeamGroupImageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.beamGroupId = data["beamGroupId"];
            this.imageFilePath = data["imageFilePath"];
            this.imageName = data["imageName"];
        }
    }

    static fromJS(data: any): BeamGroupImageDto {
        data = typeof data === 'object' ? data : {};
        let result = new BeamGroupImageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["beamGroupId"] = this.beamGroupId;
        data["imageFilePath"] = this.imageFilePath;
        data["imageName"] = this.imageName;
        return data; 
    }
}

export interface IBeamGroupImageDto {
    id: number | undefined;
    beamGroupId: number | undefined;
    imageFilePath: string | undefined;
    imageName: string | undefined;
}

export class FixationDeviceImageDto implements IFixationDeviceImageDto {
    id!: number | undefined;
    beamGroupId!: number | undefined;
    fixationImage!: string | undefined;
    descripiton!: string | undefined;

    constructor(data?: IFixationDeviceImageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.beamGroupId = data["beamGroupId"];
            this.fixationImage = data["fixationImage"];
            this.descripiton = data["descripiton"];
        }
    }

    static fromJS(data: any): FixationDeviceImageDto {
        data = typeof data === 'object' ? data : {};
        let result = new FixationDeviceImageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["beamGroupId"] = this.beamGroupId;
        data["fixationImage"] = this.fixationImage;
        data["descripiton"] = this.descripiton;
        return data; 
    }
}

export interface IFixationDeviceImageDto {
    id: number | undefined;
    beamGroupId: number | undefined;
    fixationImage: string | undefined;
    descripiton: string | undefined;
}

export class BeamGroupOutput implements IBeamGroupOutput {
    id!: number | undefined;
    planId!: number | undefined;
    beamGroupName!: string | undefined;
    isActive!: boolean | undefined;
    isApprove!: boolean | undefined;
    isCheck!: boolean | undefined;
    isCreateByTms!: boolean | undefined;
    isMachineValid!: boolean | undefined;
    beamList!: BeamOutput[] | undefined;

    constructor(data?: IBeamGroupOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.planId = data["planId"];
            this.beamGroupName = data["beamGroupName"];
            this.isActive = data["isActive"];
            this.isApprove = data["isApprove"];
            this.isCheck = data["isCheck"];
            this.isCreateByTms = data["isCreateByTms"];
            this.isMachineValid = data["isMachineValid"];
            if (data["beamList"] && data["beamList"].constructor === Array) {
                this.beamList = [];
                for (let item of data["beamList"])
                    this.beamList.push(BeamOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BeamGroupOutput {
        data = typeof data === 'object' ? data : {};
        let result = new BeamGroupOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["planId"] = this.planId;
        data["beamGroupName"] = this.beamGroupName;
        data["isActive"] = this.isActive;
        data["isApprove"] = this.isApprove;
        data["isCheck"] = this.isCheck;
        data["isCreateByTms"] = this.isCreateByTms;
        data["isMachineValid"] = this.isMachineValid;
        if (this.beamList && this.beamList.constructor === Array) {
            data["beamList"] = [];
            for (let item of this.beamList)
                data["beamList"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IBeamGroupOutput {
    id: number | undefined;
    planId: number | undefined;
    beamGroupName: string | undefined;
    isActive: boolean | undefined;
    isApprove: boolean | undefined;
    isCheck: boolean | undefined;
    isCreateByTms: boolean | undefined;
    isMachineValid: boolean | undefined;
    beamList: BeamOutput[] | undefined;
}

export class CheckBeamGroupResult implements ICheckBeamGroupResult {
    beamGroupNum!: number | undefined;
    isDuplicate!: boolean | undefined;

    constructor(data?: ICheckBeamGroupResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.beamGroupNum = data["beamGroupNum"];
            this.isDuplicate = data["isDuplicate"];
        }
    }

    static fromJS(data: any): CheckBeamGroupResult {
        data = typeof data === 'object' ? data : {};
        let result = new CheckBeamGroupResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["beamGroupNum"] = this.beamGroupNum;
        data["isDuplicate"] = this.isDuplicate;
        return data; 
    }
}

export interface ICheckBeamGroupResult {
    beamGroupNum: number | undefined;
    isDuplicate: boolean | undefined;
}

export class MachineOutput implements IMachineOutput {
    machineName!: string | undefined;
    isApproved!: boolean | undefined;
    isActived!: boolean | undefined;
    radiationList!: RadiationType[] | undefined;
    techniqueTypeList!: TechniqueType[] | undefined;

    constructor(data?: IMachineOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.machineName = data["machineName"];
            this.isApproved = data["isApproved"];
            this.isActived = data["isActived"];
            if (data["radiationList"] && data["radiationList"].constructor === Array) {
                this.radiationList = [];
                for (let item of data["radiationList"])
                    this.radiationList.push(RadiationType.fromJS(item));
            }
            if (data["techniqueTypeList"] && data["techniqueTypeList"].constructor === Array) {
                this.techniqueTypeList = [];
                for (let item of data["techniqueTypeList"])
                    this.techniqueTypeList.push(TechniqueType.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MachineOutput {
        data = typeof data === 'object' ? data : {};
        let result = new MachineOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["machineName"] = this.machineName;
        data["isApproved"] = this.isApproved;
        data["isActived"] = this.isActived;
        if (this.radiationList && this.radiationList.constructor === Array) {
            data["radiationList"] = [];
            for (let item of this.radiationList)
                data["radiationList"].push(item.toJSON());
        }
        if (this.techniqueTypeList && this.techniqueTypeList.constructor === Array) {
            data["techniqueTypeList"] = [];
            for (let item of this.techniqueTypeList)
                data["techniqueTypeList"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IMachineOutput {
    machineName: string | undefined;
    isApproved: boolean | undefined;
    isActived: boolean | undefined;
    radiationList: RadiationType[] | undefined;
    techniqueTypeList: TechniqueType[] | undefined;
}

export class BeamGroupStatusDto implements IBeamGroupStatusDto {
    isActive!: boolean | undefined;
    isApprove!: boolean | undefined;
    approvedUserName!: string | undefined;
    approvedDateTime!: string | undefined;
    isCheck!: boolean | undefined;
    isCreateByTms!: boolean | undefined;
    toleranceId!: number | undefined;
    isGating!: boolean | undefined;
    gatingModel!: number | undefined;
    id!: number | undefined;

    constructor(data?: IBeamGroupStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isActive = data["isActive"];
            this.isApprove = data["isApprove"];
            this.approvedUserName = data["approvedUserName"];
            this.approvedDateTime = data["approvedDateTime"];
            this.isCheck = data["isCheck"];
            this.isCreateByTms = data["isCreateByTms"];
            this.toleranceId = data["toleranceId"];
            this.isGating = data["isGating"];
            this.gatingModel = data["gatingModel"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): BeamGroupStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new BeamGroupStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isActive"] = this.isActive;
        data["isApprove"] = this.isApprove;
        data["approvedUserName"] = this.approvedUserName;
        data["approvedDateTime"] = this.approvedDateTime;
        data["isCheck"] = this.isCheck;
        data["isCreateByTms"] = this.isCreateByTms;
        data["toleranceId"] = this.toleranceId;
        data["isGating"] = this.isGating;
        data["gatingModel"] = this.gatingModel;
        data["id"] = this.id;
        return data; 
    }
}

export interface IBeamGroupStatusDto {
    isActive: boolean | undefined;
    isApprove: boolean | undefined;
    approvedUserName: string | undefined;
    approvedDateTime: string | undefined;
    isCheck: boolean | undefined;
    isCreateByTms: boolean | undefined;
    toleranceId: number | undefined;
    isGating: boolean | undefined;
    gatingModel: number | undefined;
    id: number | undefined;
}

export class TreatmentSummaryDto implements ITreatmentSummaryDto {
    dateCloumnList!: DateColumn[] | undefined;
    beamGroupRowList!: BeamGroupRow[] | undefined;

    constructor(data?: ITreatmentSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["dateCloumnList"] && data["dateCloumnList"].constructor === Array) {
                this.dateCloumnList = [];
                for (let item of data["dateCloumnList"])
                    this.dateCloumnList.push(DateColumn.fromJS(item));
            }
            if (data["beamGroupRowList"] && data["beamGroupRowList"].constructor === Array) {
                this.beamGroupRowList = [];
                for (let item of data["beamGroupRowList"])
                    this.beamGroupRowList.push(BeamGroupRow.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TreatmentSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new TreatmentSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.dateCloumnList && this.dateCloumnList.constructor === Array) {
            data["dateCloumnList"] = [];
            for (let item of this.dateCloumnList)
                data["dateCloumnList"].push(item.toJSON());
        }
        if (this.beamGroupRowList && this.beamGroupRowList.constructor === Array) {
            data["beamGroupRowList"] = [];
            for (let item of this.beamGroupRowList)
                data["beamGroupRowList"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITreatmentSummaryDto {
    dateCloumnList: DateColumn[] | undefined;
    beamGroupRowList: BeamGroupRow[] | undefined;
}

export class DateColumn implements IDateColumn {
    date!: moment.Moment | undefined;
    weekStr!: string | undefined;
    dateStr!: string | undefined;
    status!: number | undefined;
    number!: number | undefined;
    isGap!: boolean | undefined;

    constructor(data?: IDateColumn) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.weekStr = data["weekStr"];
            this.dateStr = data["dateStr"];
            this.status = data["status"];
            this.number = data["number"];
            this.isGap = data["isGap"];
        }
    }

    static fromJS(data: any): DateColumn {
        data = typeof data === 'object' ? data : {};
        let result = new DateColumn();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["weekStr"] = this.weekStr;
        data["dateStr"] = this.dateStr;
        data["status"] = this.status;
        data["number"] = this.number;
        data["isGap"] = this.isGap;
        return data; 
    }
}

export interface IDateColumn {
    date: moment.Moment | undefined;
    weekStr: string | undefined;
    dateStr: string | undefined;
    status: number | undefined;
    number: number | undefined;
    isGap: boolean | undefined;
}

export class BeamGroupRow implements IBeamGroupRow {
    beamGroupName!: string | undefined;
    beamGroupId!: number | undefined;
    totalDose!: number | undefined;
    dosePerFraction!: number | undefined;
    totalMu!: number | undefined;
    fractionNumber!: number | undefined;
    oneDayGroupFractionList!: OneDayGroupFraction[] | undefined;

    constructor(data?: IBeamGroupRow) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.beamGroupName = data["beamGroupName"];
            this.beamGroupId = data["beamGroupId"];
            this.totalDose = data["totalDose"];
            this.dosePerFraction = data["dosePerFraction"];
            this.totalMu = data["totalMu"];
            this.fractionNumber = data["fractionNumber"];
            if (data["oneDayGroupFractionList"] && data["oneDayGroupFractionList"].constructor === Array) {
                this.oneDayGroupFractionList = [];
                for (let item of data["oneDayGroupFractionList"])
                    this.oneDayGroupFractionList.push(OneDayGroupFraction.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BeamGroupRow {
        data = typeof data === 'object' ? data : {};
        let result = new BeamGroupRow();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["beamGroupName"] = this.beamGroupName;
        data["beamGroupId"] = this.beamGroupId;
        data["totalDose"] = this.totalDose;
        data["dosePerFraction"] = this.dosePerFraction;
        data["totalMu"] = this.totalMu;
        data["fractionNumber"] = this.fractionNumber;
        if (this.oneDayGroupFractionList && this.oneDayGroupFractionList.constructor === Array) {
            data["oneDayGroupFractionList"] = [];
            for (let item of this.oneDayGroupFractionList)
                data["oneDayGroupFractionList"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IBeamGroupRow {
    beamGroupName: string | undefined;
    beamGroupId: number | undefined;
    totalDose: number | undefined;
    dosePerFraction: number | undefined;
    totalMu: number | undefined;
    fractionNumber: number | undefined;
    oneDayGroupFractionList: OneDayGroupFraction[] | undefined;
}

export class OneDayGroupFraction implements IOneDayGroupFraction {
    groupCellList!: GroupFractionCell[] | undefined;
    isGap!: boolean | undefined;

    constructor(data?: IOneDayGroupFraction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["groupCellList"] && data["groupCellList"].constructor === Array) {
                this.groupCellList = [];
                for (let item of data["groupCellList"])
                    this.groupCellList.push(GroupFractionCell.fromJS(item));
            }
            this.isGap = data["isGap"];
        }
    }

    static fromJS(data: any): OneDayGroupFraction {
        data = typeof data === 'object' ? data : {};
        let result = new OneDayGroupFraction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.groupCellList && this.groupCellList.constructor === Array) {
            data["groupCellList"] = [];
            for (let item of this.groupCellList)
                data["groupCellList"].push(item.toJSON());
        }
        data["isGap"] = this.isGap;
        return data; 
    }
}

export interface IOneDayGroupFraction {
    groupCellList: GroupFractionCell[] | undefined;
    isGap: boolean | undefined;
}

export class GroupFractionCell implements IGroupFractionCell {
    status!: number | undefined;
    fractionIndex!: number | undefined;
    totalFractionIndex!: number | undefined;
    doseToCurrentSession!: number | undefined;
    info!: string | undefined;
    beamCellList!: BeamFractionCell[] | undefined;
    relatedRecordList!: number[] | undefined;

    constructor(data?: IGroupFractionCell) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"];
            this.fractionIndex = data["fractionIndex"];
            this.totalFractionIndex = data["totalFractionIndex"];
            this.doseToCurrentSession = data["doseToCurrentSession"];
            this.info = data["info"];
            if (data["beamCellList"] && data["beamCellList"].constructor === Array) {
                this.beamCellList = [];
                for (let item of data["beamCellList"])
                    this.beamCellList.push(BeamFractionCell.fromJS(item));
            }
            if (data["relatedRecordList"] && data["relatedRecordList"].constructor === Array) {
                this.relatedRecordList = [];
                for (let item of data["relatedRecordList"])
                    this.relatedRecordList.push(item);
            }
        }
    }

    static fromJS(data: any): GroupFractionCell {
        data = typeof data === 'object' ? data : {};
        let result = new GroupFractionCell();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["fractionIndex"] = this.fractionIndex;
        data["totalFractionIndex"] = this.totalFractionIndex;
        data["doseToCurrentSession"] = this.doseToCurrentSession;
        data["info"] = this.info;
        if (this.beamCellList && this.beamCellList.constructor === Array) {
            data["beamCellList"] = [];
            for (let item of this.beamCellList)
                data["beamCellList"].push(item.toJSON());
        }
        if (this.relatedRecordList && this.relatedRecordList.constructor === Array) {
            data["relatedRecordList"] = [];
            for (let item of this.relatedRecordList)
                data["relatedRecordList"].push(item);
        }
        return data; 
    }
}

export interface IGroupFractionCell {
    status: number | undefined;
    fractionIndex: number | undefined;
    totalFractionIndex: number | undefined;
    doseToCurrentSession: number | undefined;
    info: string | undefined;
    beamCellList: BeamFractionCell[] | undefined;
    relatedRecordList: number[] | undefined;
}

export class BeamFractionCell implements IBeamFractionCell {
    beamName!: string | undefined;
    status!: number | undefined;
    recordId!: number | undefined;
    deliveredMu!: number | undefined;

    constructor(data?: IBeamFractionCell) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.beamName = data["beamName"];
            this.status = data["status"];
            this.recordId = data["recordId"];
            this.deliveredMu = data["deliveredMu"];
        }
    }

    static fromJS(data: any): BeamFractionCell {
        data = typeof data === 'object' ? data : {};
        let result = new BeamFractionCell();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["beamName"] = this.beamName;
        data["status"] = this.status;
        data["recordId"] = this.recordId;
        data["deliveredMu"] = this.deliveredMu;
        return data; 
    }
}

export interface IBeamFractionCell {
    beamName: string | undefined;
    status: number | undefined;
    recordId: number | undefined;
    deliveredMu: number | undefined;
}

export class RecordDetailsOutput implements IRecordDetailsOutput {
    availableColumnNames!: ValueTupleOfStringAndBoolean[] | undefined;
    availableRowList!: string[][] | undefined;

    constructor(data?: IRecordDetailsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["availableColumnNames"] && data["availableColumnNames"].constructor === Array) {
                this.availableColumnNames = [];
                for (let item of data["availableColumnNames"])
                    this.availableColumnNames.push(ValueTupleOfStringAndBoolean.fromJS(item));
            }
            if (data["availableRowList"] && data["availableRowList"].constructor === Array) {
                this.availableRowList = [];
                for (let item of data["availableRowList"])
                    this.availableRowList.push(item);
            }
        }
    }

    static fromJS(data: any): RecordDetailsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RecordDetailsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.availableColumnNames && this.availableColumnNames.constructor === Array) {
            data["availableColumnNames"] = [];
            for (let item of this.availableColumnNames)
                data["availableColumnNames"].push(item.toJSON());
        }
        if (this.availableRowList && this.availableRowList.constructor === Array) {
            data["availableRowList"] = [];
            for (let item of this.availableRowList)
                data["availableRowList"].push(item);
        }
        return data; 
    }
}

export interface IRecordDetailsOutput {
    availableColumnNames: ValueTupleOfStringAndBoolean[] | undefined;
    availableRowList: string[][] | undefined;
}

export class ValueTupleOfStringAndBoolean implements IValueTupleOfStringAndBoolean {
    item1!: string | undefined;
    item2!: boolean | undefined;

    constructor(data?: IValueTupleOfStringAndBoolean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.item1 = data["item1"];
            this.item2 = data["item2"];
        }
    }

    static fromJS(data: any): ValueTupleOfStringAndBoolean {
        data = typeof data === 'object' ? data : {};
        let result = new ValueTupleOfStringAndBoolean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["item1"] = this.item1;
        data["item2"] = this.item2;
        return data; 
    }
}

export interface IValueTupleOfStringAndBoolean {
    item1: string | undefined;
    item2: boolean | undefined;
}

export class TreatmentScheduleDeliveryGroupDto implements ITreatmentScheduleDeliveryGroupDto {
    uid!: number | undefined;
    machineName!: string | undefined;
    beamGroup!: string | undefined;
    beams!: TechniqueType | undefined;
    planDescription!: string | undefined;
    id!: number | undefined;

    constructor(data?: ITreatmentScheduleDeliveryGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.uid = data["uid"];
            this.machineName = data["machineName"];
            this.beamGroup = data["beamGroup"];
            this.beams = data["beams"] ? TechniqueType.fromJS(data["beams"]) : <any>undefined;
            this.planDescription = data["planDescription"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TreatmentScheduleDeliveryGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new TreatmentScheduleDeliveryGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uid"] = this.uid;
        data["machineName"] = this.machineName;
        data["beamGroup"] = this.beamGroup;
        data["beams"] = this.beams ? this.beams.toJSON() : <any>undefined;
        data["planDescription"] = this.planDescription;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITreatmentScheduleDeliveryGroupDto {
    uid: number | undefined;
    machineName: string | undefined;
    beamGroup: string | undefined;
    beams: TechniqueType | undefined;
    planDescription: string | undefined;
    id: number | undefined;
}

export class TreatmentScheduleSessionDto implements ITreatmentScheduleSessionDto {
    id!: number | undefined;
    beamGroupId!: number | undefined;
    fractionNumber!: number | undefined;
    scheduledDate!: moment.Moment | undefined;
    scheduledTime!: moment.Moment | undefined;
    beamGroupName!: string | undefined;
    ralatedPlanName!: string | undefined;
    machineName!: string | undefined;
    planEndTime!: moment.Moment | undefined;
    status!: TreatmentSessionStatus | undefined;
    isActive!: boolean | undefined;
    isSingleWeek!: boolean | undefined;

    constructor(data?: ITreatmentScheduleSessionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.beamGroupId = data["beamGroupId"];
            this.fractionNumber = data["fractionNumber"];
            this.scheduledDate = data["scheduledDate"] ? moment(data["scheduledDate"].toString()) : <any>undefined;
            this.scheduledTime = data["scheduledTime"] ? moment(data["scheduledTime"].toString()) : <any>undefined;
            this.beamGroupName = data["beamGroupName"];
            this.ralatedPlanName = data["ralatedPlanName"];
            this.machineName = data["machineName"];
            this.planEndTime = data["planEndTime"] ? moment(data["planEndTime"].toString()) : <any>undefined;
            this.status = data["status"] ? TreatmentSessionStatus.fromJS(data["status"]) : <any>undefined;
            this.isActive = data["isActive"];
            this.isSingleWeek = data["isSingleWeek"];
        }
    }

    static fromJS(data: any): TreatmentScheduleSessionDto {
        data = typeof data === 'object' ? data : {};
        let result = new TreatmentScheduleSessionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["beamGroupId"] = this.beamGroupId;
        data["fractionNumber"] = this.fractionNumber;
        data["scheduledDate"] = this.scheduledDate ? this.scheduledDate.toISOString() : <any>undefined;
        data["scheduledTime"] = this.scheduledTime ? this.scheduledTime.toISOString() : <any>undefined;
        data["beamGroupName"] = this.beamGroupName;
        data["ralatedPlanName"] = this.ralatedPlanName;
        data["machineName"] = this.machineName;
        data["planEndTime"] = this.planEndTime ? this.planEndTime.toISOString() : <any>undefined;
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        data["isActive"] = this.isActive;
        data["isSingleWeek"] = this.isSingleWeek;
        return data; 
    }
}

export interface ITreatmentScheduleSessionDto {
    id: number | undefined;
    beamGroupId: number | undefined;
    fractionNumber: number | undefined;
    scheduledDate: moment.Moment | undefined;
    scheduledTime: moment.Moment | undefined;
    beamGroupName: string | undefined;
    ralatedPlanName: string | undefined;
    machineName: string | undefined;
    planEndTime: moment.Moment | undefined;
    status: TreatmentSessionStatus | undefined;
    isActive: boolean | undefined;
    isSingleWeek: boolean | undefined;
}

export class TreatmentSessionStatus implements ITreatmentSessionStatus {
    name!: string | undefined;
    id!: number | undefined;

    constructor(data?: ITreatmentSessionStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TreatmentSessionStatus {
        data = typeof data === 'object' ? data : {};
        let result = new TreatmentSessionStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITreatmentSessionStatus {
    name: string | undefined;
    id: number | undefined;
}

export class QueryBeamGroupSessionDto implements IQueryBeamGroupSessionDto {
    beamGroupId!: number | undefined;
    sorting!: string | undefined;
    maxResultCount!: number | undefined;
    skipCount!: number | undefined;

    constructor(data?: IQueryBeamGroupSessionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.beamGroupId = data["beamGroupId"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): QueryBeamGroupSessionDto {
        data = typeof data === 'object' ? data : {};
        let result = new QueryBeamGroupSessionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["beamGroupId"] = this.beamGroupId;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface IQueryBeamGroupSessionDto {
    beamGroupId: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfTreatmentScheduleSessionDto implements IPagedResultDtoOfTreatmentScheduleSessionDto {
    totalCount!: number | undefined;
    items!: TreatmentScheduleSessionDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTreatmentScheduleSessionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(TreatmentScheduleSessionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTreatmentScheduleSessionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTreatmentScheduleSessionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfTreatmentScheduleSessionDto {
    totalCount: number | undefined;
    items: TreatmentScheduleSessionDto[] | undefined;
}

export class TreatmentScheduleStrategyDto implements ITreatmentScheduleStrategyDto {
    id!: number | undefined;
    beamGroupId!: number | undefined;
    startDate!: moment.Moment | undefined;
    planStartTime!: moment.Moment | undefined;
    planEndTime!: moment.Moment | undefined;
    treatmentInHoliday!: boolean | undefined;
    treatmentInMonday!: boolean | undefined;
    treatmentInTuesDay!: boolean | undefined;
    treatmentInWednesday!: boolean | undefined;
    treatmentThurday!: boolean | undefined;
    treatmentFriday!: boolean | undefined;
    treatmentSaturday!: boolean | undefined;
    treatmentSunday!: boolean | undefined;
    timePerDay!: number | undefined;
    treatmentCure!: number | undefined;
    moduleName!: string | undefined;
    intervalhour!: moment.Moment | undefined;

    constructor(data?: ITreatmentScheduleStrategyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.beamGroupId = data["beamGroupId"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.planStartTime = data["planStartTime"] ? moment(data["planStartTime"].toString()) : <any>undefined;
            this.planEndTime = data["planEndTime"] ? moment(data["planEndTime"].toString()) : <any>undefined;
            this.treatmentInHoliday = data["treatmentInHoliday"];
            this.treatmentInMonday = data["treatmentInMonday"];
            this.treatmentInTuesDay = data["treatmentInTuesDay"];
            this.treatmentInWednesday = data["treatmentInWednesday"];
            this.treatmentThurday = data["treatmentThurday"];
            this.treatmentFriday = data["treatmentFriday"];
            this.treatmentSaturday = data["treatmentSaturday"];
            this.treatmentSunday = data["treatmentSunday"];
            this.timePerDay = data["timePerDay"];
            this.treatmentCure = data["treatmentCure"];
            this.moduleName = data["moduleName"];
            this.intervalhour = data["intervalhour"] ? moment(data["intervalhour"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TreatmentScheduleStrategyDto {
        data = typeof data === 'object' ? data : {};
        let result = new TreatmentScheduleStrategyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["beamGroupId"] = this.beamGroupId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["planStartTime"] = this.planStartTime ? this.planStartTime.toISOString() : <any>undefined;
        data["planEndTime"] = this.planEndTime ? this.planEndTime.toISOString() : <any>undefined;
        data["treatmentInHoliday"] = this.treatmentInHoliday;
        data["treatmentInMonday"] = this.treatmentInMonday;
        data["treatmentInTuesDay"] = this.treatmentInTuesDay;
        data["treatmentInWednesday"] = this.treatmentInWednesday;
        data["treatmentThurday"] = this.treatmentThurday;
        data["treatmentFriday"] = this.treatmentFriday;
        data["treatmentSaturday"] = this.treatmentSaturday;
        data["treatmentSunday"] = this.treatmentSunday;
        data["timePerDay"] = this.timePerDay;
        data["treatmentCure"] = this.treatmentCure;
        data["moduleName"] = this.moduleName;
        data["intervalhour"] = this.intervalhour ? this.intervalhour.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ITreatmentScheduleStrategyDto {
    id: number | undefined;
    beamGroupId: number | undefined;
    startDate: moment.Moment | undefined;
    planStartTime: moment.Moment | undefined;
    planEndTime: moment.Moment | undefined;
    treatmentInHoliday: boolean | undefined;
    treatmentInMonday: boolean | undefined;
    treatmentInTuesDay: boolean | undefined;
    treatmentInWednesday: boolean | undefined;
    treatmentThurday: boolean | undefined;
    treatmentFriday: boolean | undefined;
    treatmentSaturday: boolean | undefined;
    treatmentSunday: boolean | undefined;
    timePerDay: number | undefined;
    treatmentCure: number | undefined;
    moduleName: string | undefined;
    intervalhour: moment.Moment | undefined;
}

export class ChangeUiThemeInput implements IChangeUiThemeInput {
    theme!: string;

    constructor(data?: IChangeUiThemeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.theme = data["theme"];
        }
    }

    static fromJS(data: any): ChangeUiThemeInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUiThemeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["theme"] = this.theme;
        return data; 
    }
}

export interface IChangeUiThemeInput {
    theme: string;
}

export class LicenseOutput implements ILicenseOutput {
    productName!: string | undefined;
    expireTime!: string | undefined;
    isEnable!: boolean | undefined;
    productCode!: string | undefined;

    constructor(data?: ILicenseOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.productName = data["productName"];
            this.expireTime = data["expireTime"];
            this.isEnable = data["isEnable"];
            this.productCode = data["productCode"];
        }
    }

    static fromJS(data: any): LicenseOutput {
        data = typeof data === 'object' ? data : {};
        let result = new LicenseOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productName"] = this.productName;
        data["expireTime"] = this.expireTime;
        data["isEnable"] = this.isEnable;
        data["productCode"] = this.productCode;
        return data; 
    }
}

export interface ILicenseOutput {
    productName: string | undefined;
    expireTime: string | undefined;
    isEnable: boolean | undefined;
    productCode: string | undefined;
}

export class QueryAllSessionInput implements IQueryAllSessionInput {
    machineName!: string | undefined;
    sessionStartDate!: moment.Moment | undefined;
    sessionEndDate!: moment.Moment | undefined;
    sessionStatus!: TreatmentSessionStatus | undefined;
    patientName!: string | undefined;
    patientId!: string | undefined;
    checkedIdList!: number[] | undefined;
    sorting!: string | undefined;
    maxResultCount!: number | undefined;
    skipCount!: number | undefined;

    constructor(data?: IQueryAllSessionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.machineName = data["machineName"];
            this.sessionStartDate = data["sessionStartDate"] ? moment(data["sessionStartDate"].toString()) : <any>undefined;
            this.sessionEndDate = data["sessionEndDate"] ? moment(data["sessionEndDate"].toString()) : <any>undefined;
            this.sessionStatus = data["sessionStatus"] ? TreatmentSessionStatus.fromJS(data["sessionStatus"]) : <any>undefined;
            this.patientName = data["patientName"];
            this.patientId = data["patientId"];
            if (data["checkedIdList"] && data["checkedIdList"].constructor === Array) {
                this.checkedIdList = [];
                for (let item of data["checkedIdList"])
                    this.checkedIdList.push(item);
            }
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): QueryAllSessionInput {
        data = typeof data === 'object' ? data : {};
        let result = new QueryAllSessionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["machineName"] = this.machineName;
        data["sessionStartDate"] = this.sessionStartDate ? this.sessionStartDate.toISOString() : <any>undefined;
        data["sessionEndDate"] = this.sessionEndDate ? this.sessionEndDate.toISOString() : <any>undefined;
        data["sessionStatus"] = this.sessionStatus ? this.sessionStatus.toJSON() : <any>undefined;
        data["patientName"] = this.patientName;
        data["patientId"] = this.patientId;
        if (this.checkedIdList && this.checkedIdList.constructor === Array) {
            data["checkedIdList"] = [];
            for (let item of this.checkedIdList)
                data["checkedIdList"].push(item);
        }
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface IQueryAllSessionInput {
    machineName: string | undefined;
    sessionStartDate: moment.Moment | undefined;
    sessionEndDate: moment.Moment | undefined;
    sessionStatus: TreatmentSessionStatus | undefined;
    patientName: string | undefined;
    patientId: string | undefined;
    checkedIdList: number[] | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfTreatmentSessionDto implements IPagedResultDtoOfTreatmentSessionDto {
    totalCount!: number | undefined;
    items!: TreatmentSessionDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTreatmentSessionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(TreatmentSessionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTreatmentSessionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTreatmentSessionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfTreatmentSessionDto {
    totalCount: number | undefined;
    items: TreatmentSessionDto[] | undefined;
}

export class TreatmentSessionDto implements ITreatmentSessionDto {
    id!: number | undefined;
    beamGroupId!: number | undefined;
    fractionNumber!: number | undefined;
    scheduledDate!: moment.Moment | undefined;
    isActive!: boolean | undefined;
    beamGroupName!: string | undefined;
    patientId!: string | undefined;
    patientName!: string | undefined;
    beamType!: string | undefined;
    machineName!: string | undefined;
    planStartTime!: moment.Moment | undefined;
    status!: TreatmentSessionStatus | undefined;
    isBlue!: boolean | undefined;

    constructor(data?: ITreatmentSessionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.beamGroupId = data["beamGroupId"];
            this.fractionNumber = data["fractionNumber"];
            this.scheduledDate = data["scheduledDate"] ? moment(data["scheduledDate"].toString()) : <any>undefined;
            this.isActive = data["isActive"];
            this.beamGroupName = data["beamGroupName"];
            this.patientId = data["patientId"];
            this.patientName = data["patientName"];
            this.beamType = data["beamType"];
            this.machineName = data["machineName"];
            this.planStartTime = data["planStartTime"] ? moment(data["planStartTime"].toString()) : <any>undefined;
            this.status = data["status"] ? TreatmentSessionStatus.fromJS(data["status"]) : <any>undefined;
            this.isBlue = data["isBlue"];
        }
    }

    static fromJS(data: any): TreatmentSessionDto {
        data = typeof data === 'object' ? data : {};
        let result = new TreatmentSessionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["beamGroupId"] = this.beamGroupId;
        data["fractionNumber"] = this.fractionNumber;
        data["scheduledDate"] = this.scheduledDate ? this.scheduledDate.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["beamGroupName"] = this.beamGroupName;
        data["patientId"] = this.patientId;
        data["patientName"] = this.patientName;
        data["beamType"] = this.beamType;
        data["machineName"] = this.machineName;
        data["planStartTime"] = this.planStartTime ? this.planStartTime.toISOString() : <any>undefined;
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        data["isBlue"] = this.isBlue;
        return data; 
    }
}

export interface ITreatmentSessionDto {
    id: number | undefined;
    beamGroupId: number | undefined;
    fractionNumber: number | undefined;
    scheduledDate: moment.Moment | undefined;
    isActive: boolean | undefined;
    beamGroupName: string | undefined;
    patientId: string | undefined;
    patientName: string | undefined;
    beamType: string | undefined;
    machineName: string | undefined;
    planStartTime: moment.Moment | undefined;
    status: TreatmentSessionStatus | undefined;
    isBlue: boolean | undefined;
}

export class ListResultDtoOfPatientDto implements IListResultDtoOfPatientDto {
    items!: PatientDto[] | undefined;

    constructor(data?: IListResultDtoOfPatientDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(PatientDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfPatientDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfPatientDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfPatientDto {
    items: PatientDto[] | undefined;
}

export class PatientDto implements IPatientDto {
    patientName!: string | undefined;
    patientID!: string | undefined;
    patientsBirthDate!: moment.Moment | undefined;
    patientSex!: string | undefined;
    patientAge!: string | undefined;
    creatorUserId!: string | undefined;
    patientFolderId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IPatientDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.patientName = data["patientName"];
            this.patientID = data["patientID"];
            this.patientsBirthDate = data["patientsBirthDate"] ? moment(data["patientsBirthDate"].toString()) : <any>undefined;
            this.patientSex = data["patientSex"];
            this.patientAge = data["patientAge"];
            this.creatorUserId = data["creatorUserId"];
            this.patientFolderId = data["patientFolderId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PatientDto {
        data = typeof data === 'object' ? data : {};
        let result = new PatientDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["patientName"] = this.patientName;
        data["patientID"] = this.patientID;
        data["patientsBirthDate"] = this.patientsBirthDate ? this.patientsBirthDate.toISOString() : <any>undefined;
        data["patientSex"] = this.patientSex;
        data["patientAge"] = this.patientAge;
        data["creatorUserId"] = this.creatorUserId;
        data["patientFolderId"] = this.patientFolderId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IPatientDto {
    patientName: string | undefined;
    patientID: string | undefined;
    patientsBirthDate: moment.Moment | undefined;
    patientSex: string | undefined;
    patientAge: string | undefined;
    creatorUserId: string | undefined;
    patientFolderId: number | undefined;
    id: number | undefined;
}

export class TableDisplayConfigDto implements ITableDisplayConfigDto {
    columnName!: string | undefined;
    columnDisplayName!: string | undefined;
    isDisplay!: boolean | undefined;
    displayIndex!: number | undefined;
    id!: number | undefined;

    constructor(data?: ITableDisplayConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.columnName = data["columnName"];
            this.columnDisplayName = data["columnDisplayName"];
            this.isDisplay = data["isDisplay"];
            this.displayIndex = data["displayIndex"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TableDisplayConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new TableDisplayConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["columnName"] = this.columnName;
        data["columnDisplayName"] = this.columnDisplayName;
        data["isDisplay"] = this.isDisplay;
        data["displayIndex"] = this.displayIndex;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITableDisplayConfigDto {
    columnName: string | undefined;
    columnDisplayName: string | undefined;
    isDisplay: boolean | undefined;
    displayIndex: number | undefined;
    id: number | undefined;
}

export class ToleranceDto implements IToleranceDto {
    toleranceTableLabel!: string | undefined;
    technique!: number | undefined;
    gantryAngle!: number | undefined;
    beamLimitingDeviceAngle!: number | undefined;
    patientSupportAngle!: number | undefined;
    tableVRT!: number | undefined;
    tableLAT!: number | undefined;
    tableLNG!: number | undefined;
    beamLimitingDevicePosition_X!: number | undefined;
    beamLimitingDevicePosition_Y!: number | undefined;
    beamLimitingDevicePosition_ASYMX!: number | undefined;
    beamLimitingDevicePosition_ASYMY!: number | undefined;
    beamLimitingDevicePosition_MLCX!: number | undefined;
    beamLimitingDevicePosition_MLCY!: number | undefined;
    id!: number | undefined;

    constructor(data?: IToleranceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.toleranceTableLabel = data["toleranceTableLabel"];
            this.technique = data["technique"];
            this.gantryAngle = data["gantryAngle"];
            this.beamLimitingDeviceAngle = data["beamLimitingDeviceAngle"];
            this.patientSupportAngle = data["patientSupportAngle"];
            this.tableVRT = data["tableVRT"];
            this.tableLAT = data["tableLAT"];
            this.tableLNG = data["tableLNG"];
            this.beamLimitingDevicePosition_X = data["beamLimitingDevicePosition_X"];
            this.beamLimitingDevicePosition_Y = data["beamLimitingDevicePosition_Y"];
            this.beamLimitingDevicePosition_ASYMX = data["beamLimitingDevicePosition_ASYMX"];
            this.beamLimitingDevicePosition_ASYMY = data["beamLimitingDevicePosition_ASYMY"];
            this.beamLimitingDevicePosition_MLCX = data["beamLimitingDevicePosition_MLCX"];
            this.beamLimitingDevicePosition_MLCY = data["beamLimitingDevicePosition_MLCY"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ToleranceDto {
        data = typeof data === 'object' ? data : {};
        let result = new ToleranceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["toleranceTableLabel"] = this.toleranceTableLabel;
        data["technique"] = this.technique;
        data["gantryAngle"] = this.gantryAngle;
        data["beamLimitingDeviceAngle"] = this.beamLimitingDeviceAngle;
        data["patientSupportAngle"] = this.patientSupportAngle;
        data["tableVRT"] = this.tableVRT;
        data["tableLAT"] = this.tableLAT;
        data["tableLNG"] = this.tableLNG;
        data["beamLimitingDevicePosition_X"] = this.beamLimitingDevicePosition_X;
        data["beamLimitingDevicePosition_Y"] = this.beamLimitingDevicePosition_Y;
        data["beamLimitingDevicePosition_ASYMX"] = this.beamLimitingDevicePosition_ASYMX;
        data["beamLimitingDevicePosition_ASYMY"] = this.beamLimitingDevicePosition_ASYMY;
        data["beamLimitingDevicePosition_MLCX"] = this.beamLimitingDevicePosition_MLCX;
        data["beamLimitingDevicePosition_MLCY"] = this.beamLimitingDevicePosition_MLCY;
        data["id"] = this.id;
        return data; 
    }
}

export interface IToleranceDto {
    toleranceTableLabel: string | undefined;
    technique: number | undefined;
    gantryAngle: number | undefined;
    beamLimitingDeviceAngle: number | undefined;
    patientSupportAngle: number | undefined;
    tableVRT: number | undefined;
    tableLAT: number | undefined;
    tableLNG: number | undefined;
    beamLimitingDevicePosition_X: number | undefined;
    beamLimitingDevicePosition_Y: number | undefined;
    beamLimitingDevicePosition_ASYMX: number | undefined;
    beamLimitingDevicePosition_ASYMY: number | undefined;
    beamLimitingDevicePosition_MLCX: number | undefined;
    beamLimitingDevicePosition_MLCY: number | undefined;
    id: number | undefined;
}

export class ToleranceTreeDto implements IToleranceTreeDto {
    toleranceTableLabel!: string | undefined;
    id!: number | undefined;

    constructor(data?: IToleranceTreeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.toleranceTableLabel = data["toleranceTableLabel"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ToleranceTreeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ToleranceTreeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["toleranceTableLabel"] = this.toleranceTableLabel;
        data["id"] = this.id;
        return data; 
    }
}

export interface IToleranceTreeDto {
    toleranceTableLabel: string | undefined;
    id: number | undefined;
}

export class UserIdentityInput implements IUserIdentityInput {
    userName!: string | undefined;
    password!: string | undefined;

    constructor(data?: IUserIdentityInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): UserIdentityInput {
        data = typeof data === 'object' ? data : {};
        let result = new UserIdentityInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        return data; 
    }
}

export interface IUserIdentityInput {
    userName: string | undefined;
    password: string | undefined;
}

export enum Sorter {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = function() { 
                observer.next(this.result);
                observer.complete();
            }
            reader.readAsText(blob); 
        }
    });
}